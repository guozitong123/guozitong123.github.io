<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spark实验四</title>
      <link href="/2023/05/28/spark%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
      <url>/2023/05/28/spark%E5%AE%9E%E9%AA%8C%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spark实验三</title>
      <link href="/2023/05/28/spark%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
      <url>/2023/05/28/spark%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spark实验二</title>
      <link href="/2023/05/28/spark%E5%AE%9E%E9%AA%8C%E4%BA%8C/"/>
      <url>/2023/05/28/spark%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spark实验一</title>
      <link href="/2023/05/28/spark%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>/2023/05/28/spark%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫可视化</title>
      <link href="/2023/05/28/%E7%88%AC%E8%99%AB%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2023/05/28/%E7%88%AC%E8%99%AB%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫，数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据主题赛</title>
      <link href="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/"/>
      <url>/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-数据分析-x3D-x3D"><a href="#x3D-x3D-数据分析-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;数据分析&#x3D;&#x3D;"></a>&#x3D;&#x3D;数据分析&#x3D;&#x3D;</h2><p><strong>注：本项目参与了中国计算机设计大赛，里面的数据源是由和鲸社区提供的</strong></p><h3 id="1-全球温度变化趋势"><a href="#1-全球温度变化趋势" class="headerlink" title="1.全球温度变化趋势"></a>1.全球温度变化趋势</h3><h4 id="（1）数据处理"><a href="#（1）数据处理" class="headerlink" title="（1）数据处理"></a>（1）数据处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将近三十年的温度平均温度计算出来</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">file=pd.read_csv(<span class="string">&quot;/home/mw/input/temp6990/Temp.csv&quot;</span>)</span><br><span class="line">s=np.array(file)</span><br><span class="line">l=<span class="built_in">len</span>(file)</span><br><span class="line">d=[]</span><br><span class="line">avg=[]</span><br><span class="line">s_two=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">71</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,l):</span><br><span class="line">        <span class="keyword">if</span> np.<span class="built_in">abs</span>(s[j,i])&gt;<span class="number">0</span>:   <span class="comment">#将数据中不为空的数值提取出来，这里用了一个绝对值函数</span></span><br><span class="line">            d.append(s[j,i])       </span><br><span class="line">    a=np.average(d)</span><br><span class="line">    a=<span class="string">&quot;%.3f&quot;</span> % a</span><br><span class="line">    avg.append(a)</span><br><span class="line"><span class="built_in">print</span>(avg)</span><br></pre></td></tr></table></figure><h4 id="（2）数据可视化"><a href="#（2）数据可视化" class="headerlink" title="（2）数据可视化"></a>（2）数据可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全球近三十年平均温度概览</span></span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line">line_chart = Line()</span><br><span class="line"><span class="comment"># 添加x轴与y轴，以及多条折线数据</span></span><br><span class="line">year=<span class="built_in">range</span>(<span class="number">1990</span>,<span class="number">2022</span>)</span><br><span class="line">x_data = year</span><br><span class="line">y_data = [<span class="string">&#x27;0.106&#x27;</span>, <span class="string">&#x27;0.109&#x27;</span>, <span class="string">&#x27;0.125&#x27;</span>, <span class="string">&#x27;0.141&#x27;</span>, <span class="string">&#x27;0.146&#x27;</span>, <span class="string">&#x27;0.157&#x27;</span>, <span class="string">&#x27;0.181&#x27;</span>, <span class="string">&#x27;0.196&#x27;</span>, <span class="string">&#x27;0.209&#x27;</span>, <span class="string">&#x27;0.226&#x27;</span>, <span class="string">&#x27;0.244&#x27;</span>, <span class="string">&#x27;0.260&#x27;</span>, <span class="string">&#x27;0.272&#x27;</span>, <span class="string">&#x27;0.286&#x27;</span>, <span class="string">&#x27;0.299&#x27;</span>, <span class="string">&#x27;0.316&#x27;</span>, <span class="string">&#x27;0.327&#x27;</span>, <span class="string">&#x27;0.339&#x27;</span>, <span class="string">&#x27;0.356&#x27;</span>, <span class="string">&#x27;0.365&#x27;</span>, <span class="string">&#x27;0.376&#x27;</span>, <span class="string">&#x27;0.387&#x27;</span>, <span class="string">&#x27;0.401&#x27;</span>, <span class="string">&#x27;0.418&#x27;</span>, <span class="string">&#x27;0.437&#x27;</span>, <span class="string">&#x27;0.453&#x27;</span>, <span class="string">&#x27;0.468&#x27;</span>, <span class="string">&#x27;0.485&#x27;</span>, <span class="string">&#x27;0.504&#x27;</span>, <span class="string">&#x27;0.518&#x27;</span>]</span><br><span class="line">line_chart.add_xaxis(xaxis_data=x_data)</span><br><span class="line">line_chart.add_yaxis(series_name=<span class="string">&quot;temp&quot;</span>, y_axis=y_data, is_smooth=<span class="literal">True</span>, linestyle_opts=opts.LineStyleOpts(width=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 配置折线图标题、图例以及全局样式</span></span><br><span class="line">line_chart.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;全球近三十年平均温度概览&quot;</span>),</span><br><span class="line">                           legend_opts=opts.LegendOpts(is_show=<span class="literal">True</span>, type_=<span class="string">&#x27;plain&#x27;</span>),</span><br><span class="line">                           xaxis_opts=opts.AxisOpts(name=<span class="string">&quot;温度&quot;</span>, is_scale=<span class="literal">True</span>),</span><br><span class="line">                           yaxis_opts=opts.AxisOpts(name=<span class="string">&quot;年份&quot;</span>, is_scale=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 显示渲染后的图表</span></span><br><span class="line">line_chart.render_notebook()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.2.png" alt="1.2"></p><h4 id="（3）分析"><a href="#（3）分析" class="headerlink" title="（3）分析"></a>（3）分析</h4><p>由可视化结果可知，全球温度变化呈现一个递增的趋势，接下来可以去看一下温度变化所导致的影响。</p><h3 id="2-濒危物种情况概览"><a href="#2-濒危物种情况概览" class="headerlink" title="2.濒危物种情况概览"></a>2.濒危物种情况概览</h3><h4 id="（1）数据处理-1"><a href="#（1）数据处理-1" class="headerlink" title="（1）数据处理"></a>（1）数据处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment">#用thousands参数来处理以“千分位分隔符”表示的数据</span></span><br><span class="line">file1=pd.read_csv(<span class="string">&#x27;/home/mw/input/endangered3545/Critically Endangered.csv&#x27;</span>,thousands=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">file2=pd.read_csv(<span class="string">&#x27;/home/mw/input/endangered3545/Endangered.csv&#x27;</span>,thousands=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">file3=pd.read_csv(<span class="string">&#x27;/home/mw/input/endangered3545/Vulnerable.csv&#x27;</span>,thousands=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(file1.head(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(file2.head(<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(file3.head(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><h4 id="（2）数据可视化-1"><a href="#（2）数据可视化-1" class="headerlink" title="（2）数据可视化"></a>（2）数据可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line">file1=pd.read_csv(<span class="string">&#x27;/home/mw/input/endangered3545/Critically Endangered.csv&#x27;</span>,thousands=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">file2=pd.read_csv(<span class="string">&#x27;/home/mw/input/endangered3545/Endangered.csv&#x27;</span>,thousands=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">file3=pd.read_csv(<span class="string">&#x27;/home/mw/input/endangered3545/Vulnerable.csv&#x27;</span>,thousands=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">bar = (</span><br><span class="line">Bar(init_opts = opts.InitOpts(</span><br><span class="line">theme =ThemeType.PURPLE_PASSION,</span><br><span class="line">)) <span class="comment">#ThemeType. 可以更换不同的主题</span></span><br><span class="line">.add_xaxis(file1[<span class="string">&#x27;Year&#x27;</span>].tolist()) <span class="comment">#添加横坐标，放入字段名，转换为列表.tolist()</span></span><br><span class="line">.add_yaxis(<span class="string">&#x27;极度濒危&#x27;</span>,file1[<span class="string">&#x27;TOTAL&#x27;</span>].tolist(),stack=<span class="string">&quot;1&quot;</span>, category_gap=<span class="string">&quot;50%&quot;</span>)</span><br><span class="line">.add_yaxis(<span class="string">&#x27;濒危&#x27;</span>,file2[<span class="string">&#x27;TOTAL&#x27;</span>].tolist(),stack=<span class="string">&quot;1&quot;</span>, category_gap=<span class="string">&quot;50%&quot;</span>)</span><br><span class="line">.add_yaxis(<span class="string">&#x27;危险&#x27;</span>,file3[<span class="string">&#x27;TOTAL&#x27;</span>].tolist(),stack=<span class="string">&quot;1&quot;</span>, category_gap=<span class="string">&quot;50%&quot;</span>)<span class="comment">#category_gap柱状体之间的间隙大小</span></span><br><span class="line">.set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>)) <span class="comment">#系列配置项，False数值不在界面显示</span></span><br><span class="line">.set_global_opts(title_opts=opts.TitleOpts(title = <span class="string">&quot;柱状堆叠图&quot;</span>), <span class="comment">#全局配置项</span></span><br><span class="line">xaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(rotate=<span class="number">30</span>))) <span class="comment">#x轴上面的字段旋转30度</span></span><br><span class="line">)</span><br><span class="line">bar.render_notebook()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.3.png" alt="1.3"></p><h4 id="（3）分析-1"><a href="#（3）分析-1" class="headerlink" title="（3）分析"></a>（3）分析</h4><p>濒危物种数量都是逐年增加的，可能是由于全球温度升高引起的，间接影响到了生物物种数量</p><h3 id="3-我国历年碳排放量变化趋势"><a href="#3-我国历年碳排放量变化趋势" class="headerlink" title="3.我国历年碳排放量变化趋势"></a>3.我国历年碳排放量变化趋势</h3><h4 id="（1）数据处理-2"><a href="#（1）数据处理-2" class="headerlink" title="（1）数据处理"></a>（1）数据处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">file=pd.read_csv(<span class="string">&#x27;/home/mw/project/温室气体排放.csv&#x27;</span>)</span><br><span class="line">file</span><br></pre></td></tr></table></figure><h4 id="（2）数据可视化-2"><a href="#（2）数据可视化-2" class="headerlink" title="（2）数据可视化"></a>（2）数据可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br><span class="line">file=pd.read_csv(<span class="string">&#x27;/home/mw/project/温室气体排放.csv&#x27;</span>)</span><br><span class="line">bar = (</span><br><span class="line">Bar(init_opts = opts.InitOpts(</span><br><span class="line">theme =ThemeType.VINTAGE,</span><br><span class="line">)) <span class="comment">#ThemeType. 可以更换不同的主题</span></span><br><span class="line">.add_xaxis(file[<span class="string">&#x27;Year&#x27;</span>].tolist()) <span class="comment">#添加横坐标，放入字段名，转换为列表.tolist()</span></span><br><span class="line">.add_yaxis(<span class="string">&#x27;排放量（单位：亿吨）&#x27;</span>,file[<span class="string">&#x27;emission&#x27;</span>].tolist(),stack=<span class="string">&quot;1&quot;</span>, category_gap=<span class="string">&quot;50%&quot;</span>)</span><br><span class="line">.set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>))</span><br><span class="line">.set_global_opts(title_opts=opts.TitleOpts(title = <span class="string">&quot;我国历年碳排放数据&quot;</span>), <span class="comment">#全局配置项</span></span><br><span class="line">xaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(rotate=<span class="number">30</span>))) <span class="comment">#x轴上面的字段旋转30度</span></span><br><span class="line">)</span><br><span class="line">bar.render_notebook()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.4.png" alt="1.4"></p><h4 id="（3）分析-2"><a href="#（3）分析-2" class="headerlink" title="（3）分析"></a>（3）分析</h4><p>上图可知，我国碳排放数量是逐年增加的，碳排放量增加，温度升高，濒危物种增多，他们之间可能由某种联系，后面会进行三者的相关性分析。</p><h3 id="4-我国历年温度变化趋势"><a href="#4-我国历年温度变化趋势" class="headerlink" title="4.我国历年温度变化趋势"></a>4.我国历年温度变化趋势</h3><h4 id="（1）数据处理-3"><a href="#（1）数据处理-3" class="headerlink" title="（1）数据处理"></a>（1）数据处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">file=pd.read_csv(<span class="string">&quot;/home/mw/input/temp6990/Temp.csv&quot;</span>)</span><br><span class="line">s=np.array(file)</span><br><span class="line">d=[]</span><br><span class="line">i=<span class="number">42</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>,<span class="number">71</span>):</span><br><span class="line">    <span class="keyword">if</span> np.<span class="built_in">abs</span>(s[i,j])&gt;<span class="number">0</span>:  <span class="comment">#去除空值</span></span><br><span class="line">        d.append(s[i,j])</span><br><span class="line">d</span><br></pre></td></tr></table></figure><h4 id="（2）数据可视化-3"><a href="#（2）数据可视化-3" class="headerlink" title="（2）数据可视化"></a>（2）数据可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line">line_chart = Line()</span><br><span class="line"><span class="comment"># 添加x轴与y轴，以及多条折线数据</span></span><br><span class="line">year=<span class="built_in">range</span>(<span class="number">1991</span>,<span class="number">2021</span>)</span><br><span class="line">x_data = year</span><br><span class="line">y_data = [<span class="number">0.51</span>,<span class="number">0.113</span>,<span class="number">0.265</span>,<span class="number">0.719</span>,<span class="number">0.562</span>,<span class="number">0.196</span>,<span class="number">0.719</span>,<span class="number">1.246</span>,<span class="number">1.212</span>,<span class="number">0.554</span>,<span class="number">1.02</span>,<span class="number">1.113</span>,<span class="number">0.8</span>,<span class="number">1.085</span>,<span class="number">1.022</span>,<span class="number">1.205</span>,<span class="number">1.511</span>,<span class="number">1.063</span>,<span class="number">1.311</span>,<span class="number">0.942</span>,<span class="number">0.764</span>,<span class="number">0.596</span>,<span class="number">1.05</span>,</span><br><span class="line"><span class="number">1.044</span>,<span class="number">1.279</span>,<span class="number">1.305</span>,<span class="number">1.566</span>,<span class="number">1.35</span>,<span class="number">1.413</span>,<span class="number">1.636</span>,<span class="number">1.714</span>]</span><br><span class="line">line_chart.add_xaxis(xaxis_data=x_data)</span><br><span class="line">line_chart.add_yaxis(series_name=<span class="string">&quot;temp&quot;</span>, y_axis=y_data, is_smooth=<span class="literal">True</span>, linestyle_opts=opts.LineStyleOpts(width=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 配置折线图标题、图例以及全局样式</span></span><br><span class="line">line_chart.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;中国1991—2021年地表温度概览&quot;</span>),</span><br><span class="line">                           legend_opts=opts.LegendOpts(is_show=<span class="literal">True</span>, type_=<span class="string">&#x27;plain&#x27;</span>),</span><br><span class="line">                           xaxis_opts=opts.AxisOpts(name=<span class="string">&quot;年份&quot;</span>, is_scale=<span class="literal">True</span>),</span><br><span class="line">                           yaxis_opts=opts.AxisOpts(name=<span class="string">&quot;温度&quot;</span>, is_scale=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 显示渲染后的图表</span></span><br><span class="line">line_chart.render_notebook()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.5.png" alt="1.5"></p><h4 id="（3）分析-3"><a href="#（3）分析-3" class="headerlink" title="（3）分析"></a>（3）分析</h4><p>可以看到虽然温度虽然波动幅度较大，但是逐渐是一个递增的趋势的。</p><h3 id="5-我国历年经济变化趋势"><a href="#5-我国历年经济变化趋势" class="headerlink" title="5.我国历年经济变化趋势"></a>5.我国历年经济变化趋势</h3><h4 id="（1）数据可视化"><a href="#（1）数据可视化" class="headerlink" title="（1）数据可视化"></a>（1）数据可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">line_chart = Line()</span><br><span class="line">df = pd.read_csv(<span class="string">&quot;/home/mw/project/economy.csv&quot;</span>)</span><br><span class="line">x=df[<span class="string">&#x27;year&#x27;</span>]   </span><br><span class="line">y=df[<span class="string">&#x27;economy&#x27;</span>]/<span class="number">10000000</span></span><br><span class="line">line_chart.add_xaxis(xaxis_data=x)</span><br><span class="line">line_chart.add_yaxis(series_name=<span class="string">&quot;temp&quot;</span>, y_axis=y, is_smooth=<span class="literal">True</span>, linestyle_opts=opts.LineStyleOpts(width=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 配置折线图标题、图例以及全局样式</span></span><br><span class="line">line_chart.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;我国历年经济变化趋势&quot;</span>),</span><br><span class="line">                           legend_opts=opts.LegendOpts(is_show=<span class="literal">True</span>, type_=<span class="string">&#x27;plain&#x27;</span>),</span><br><span class="line">                           xaxis_opts=opts.AxisOpts(name=<span class="string">&quot;年份&quot;</span>, is_scale=<span class="literal">True</span>),</span><br><span class="line">                           yaxis_opts=opts.AxisOpts(name=<span class="string">&quot;经济（千万）&quot;</span>, is_scale=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 显示渲染后的图表</span></span><br><span class="line">line_chart.render_notebook()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.6.png" alt="1.6"></p><h4 id="（2）分析"><a href="#（2）分析" class="headerlink" title="（2）分析"></a>（2）分析</h4><p>我国的经济逐年递增的，经济，温度，濒危物种之间可能也有某种联系。</p><h3 id="6-碳排放量，经济，濒危物种之间的关系"><a href="#6-碳排放量，经济，濒危物种之间的关系" class="headerlink" title="6.碳排放量，经济，濒危物种之间的关系"></a>6.碳排放量，经济，濒危物种之间的关系</h3><h4 id="（1）经济和碳排放的关系"><a href="#（1）经济和碳排放的关系" class="headerlink" title="（1）经济和碳排放的关系"></a>（1）经济和碳排放的关系</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">line_chart = Line()</span><br><span class="line"></span><br><span class="line">filename=<span class="string">&quot;/home/mw/project/温室气体排放.csv&quot;</span></span><br><span class="line">filename1=<span class="string">&quot;/home/mw/project/economy.csv&quot;</span></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(filename)</span><br><span class="line">df1 = pd.read_csv(filename1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x=df[<span class="string">&#x27;emission&#x27;</span>]  </span><br><span class="line">y=df1[<span class="string">&#x27;economy&#x27;</span>]/<span class="number">10000000</span></span><br><span class="line">line_chart.add_xaxis(xaxis_data=x)</span><br><span class="line">line_chart.add_yaxis(series_name=<span class="string">&quot;temp&quot;</span>, y_axis=y, is_smooth=<span class="literal">True</span>, linestyle_opts=opts.LineStyleOpts(width=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 配置折线图标题、图例以及全局样式</span></span><br><span class="line">line_chart.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;经济与碳排放的关系&quot;</span>),</span><br><span class="line">                           legend_opts=opts.LegendOpts(is_show=<span class="literal">True</span>, type_=<span class="string">&#x27;plain&#x27;</span>),</span><br><span class="line">                           xaxis_opts=opts.AxisOpts(name=<span class="string">&quot;碳排放&quot;</span>, is_scale=<span class="literal">True</span>),</span><br><span class="line">                           yaxis_opts=opts.AxisOpts(name=<span class="string">&quot;经济（千万）&quot;</span>, is_scale=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 显示渲染后的图表</span></span><br><span class="line">line_chart.render_notebook()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.7.png" alt="1.7"></p><h4 id="（2）濒危物种与碳排放的关系"><a href="#（2）濒危物种与碳排放的关系" class="headerlink" title="（2）濒危物种与碳排放的关系"></a>（2）濒危物种与碳排放的关系</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">line_chart = Line()</span><br><span class="line"></span><br><span class="line">filename=<span class="string">&quot;温室气体排放.csv&quot;</span></span><br><span class="line">filename1=<span class="string">&quot;历年濒危物种数量.csv&quot;</span></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(filename)</span><br><span class="line">df1 = pd.read_csv(filename1)</span><br><span class="line"></span><br><span class="line">x=df[<span class="string">&#x27;emission&#x27;</span>]  </span><br><span class="line">y=df1[<span class="string">&#x27;Total&#x27;</span>]</span><br><span class="line">line_chart.add_xaxis(xaxis_data=x)</span><br><span class="line">line_chart.add_yaxis(series_name=<span class="string">&quot;temp&quot;</span>, y_axis=y, is_smooth=<span class="literal">True</span>, linestyle_opts=opts.LineStyleOpts(width=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 配置折线图标题、图例以及全局样式</span></span><br><span class="line">line_chart.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;濒危物种与碳排放的关系&quot;</span>),</span><br><span class="line">                           legend_opts=opts.LegendOpts(is_show=<span class="literal">True</span>, type_=<span class="string">&#x27;plain&#x27;</span>),</span><br><span class="line">                           xaxis_opts=opts.AxisOpts(name=<span class="string">&quot;碳排放&quot;</span>, is_scale=<span class="literal">True</span>),</span><br><span class="line">                           yaxis_opts=opts.AxisOpts(name=<span class="string">&quot;濒危物种&quot;</span>, is_scale=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 显示渲染后的图表</span></span><br><span class="line">line_chart.render_notebook()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.8.png" alt="1.8"></p><h4 id="（3）经济与濒危物种的关系"><a href="#（3）经济与濒危物种的关系" class="headerlink" title="（3）经济与濒危物种的关系"></a>（3）经济与濒危物种的关系</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">line_chart = Line()</span><br><span class="line"></span><br><span class="line">filename=<span class="string">&quot;/home/mw/project/economy.csv&quot;</span></span><br><span class="line">filename1=<span class="string">&quot;/home/mw/project/历年濒危物种数量.csv&quot;</span></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(filename)</span><br><span class="line">df1 = pd.read_csv(filename1)</span><br><span class="line"></span><br><span class="line">x=df[<span class="string">&#x27;economy&#x27;</span>]/<span class="number">10000000</span>   </span><br><span class="line">y=df1[<span class="string">&#x27;Total&#x27;</span>]</span><br><span class="line">line_chart.add_xaxis(xaxis_data=x)</span><br><span class="line">line_chart.add_yaxis(series_name=<span class="string">&quot;temp&quot;</span>, y_axis=y, is_smooth=<span class="literal">True</span>, linestyle_opts=opts.LineStyleOpts(width=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 配置折线图标题、图例以及全局样式</span></span><br><span class="line">line_chart.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;经济与濒危物种的关系&quot;</span>),</span><br><span class="line">                           legend_opts=opts.LegendOpts(is_show=<span class="literal">True</span>, type_=<span class="string">&#x27;plain&#x27;</span>),</span><br><span class="line">                           xaxis_opts=opts.AxisOpts(name=<span class="string">&quot;经济&quot;</span>, is_scale=<span class="literal">True</span>),</span><br><span class="line">                           yaxis_opts=opts.AxisOpts(name=<span class="string">&quot;濒危物种&quot;</span>, is_scale=<span class="literal">True</span>))</span><br><span class="line"><span class="comment"># 显示渲染后的图表</span></span><br><span class="line">line_chart.render_notebook()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.9.png" alt="1.9"></p><h3 id="7-相关性分析"><a href="#7-相关性分析" class="headerlink" title="7.相关性分析"></a>7.相关性分析</h3><h4 id="（1）数据处理-4"><a href="#（1）数据处理-4" class="headerlink" title="（1）数据处理"></a>（1）数据处理</h4><p>读取数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df1 = pd.read_csv(<span class="string">&#x27;历年濒危物种数量.csv&#x27;</span>)</span><br><span class="line">df2 = pd.read_csv(<span class="string">&#x27;economy.csv&#x27;</span>)</span><br><span class="line">df3 = pd.read_csv(<span class="string">&#x27;温室气体排放.csv&#x27;</span>)</span><br><span class="line">data1 = df1[<span class="string">&#x27;Total&#x27;</span>]</span><br><span class="line">data2 = df2[<span class="string">&#x27;economy&#x27;</span>]</span><br><span class="line">data3 = df3[<span class="string">&#x27;emission&#x27;</span>]</span><br></pre></td></tr></table></figure><p>由与文件中数据长度不同，我们在此选择交集来进行分析</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">21</span>):</span><br><span class="line">    X.append(data1[i])</span><br><span class="line">X   <span class="comment">#这个是2000-2020年</span></span><br><span class="line"></span><br><span class="line">Y=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>,<span class="number">30</span>):</span><br><span class="line">    Y.append(data2[i])</span><br><span class="line">Y   <span class="comment">#这个是2000-2020年</span></span><br><span class="line"></span><br><span class="line">Z=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>,<span class="number">30</span>):</span><br><span class="line">    Z.append(data3[i])</span><br><span class="line">Z   <span class="comment">#这个是2000-2020年</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,<span class="string">&#x27;\n&#x27;</span>,b,<span class="string">&#x27;\n&#x27;</span>,c)</span><br></pre></td></tr></table></figure><p>由于三组数据之间差值较大，为了分析数据的精确性，我们做归一化处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算最大值和最小值</span></span><br><span class="line">max_val1 = <span class="built_in">max</span>(X)</span><br><span class="line">min_val1 = <span class="built_in">min</span>(X)</span><br><span class="line">max_val2 = <span class="built_in">max</span>(Y)</span><br><span class="line">min_val2 = <span class="built_in">min</span>(Y)</span><br><span class="line">max_val3 = <span class="built_in">max</span>(Z)</span><br><span class="line">min_val3 = <span class="built_in">min</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化处理</span></span><br><span class="line">normalized_lst1 = [(x - min_val1) / (max_val1 - min_val1) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">normalized_lst2 = [(x - min_val2) / (max_val2 - min_val2) <span class="keyword">for</span> x <span class="keyword">in</span> Y]</span><br><span class="line">normalized_lst3 = [(x - min_val3) / (max_val3 - min_val3) <span class="keyword">for</span> x <span class="keyword">in</span> Z]</span><br><span class="line"><span class="built_in">print</span>(normalized_lst1)</span><br><span class="line"><span class="built_in">print</span>(normalized_lst2)</span><br><span class="line"><span class="built_in">print</span>(normalized_lst3)</span><br><span class="line">np.savetxt(<span class="string">&quot;历年濒危物种数量1.csv&quot;</span>, normalized_lst1, delimiter=<span class="string">&#x27;,&#x27;</span>,fmt = <span class="string">&#x27;%s&#x27;</span>)</span><br><span class="line">np.savetxt(<span class="string">&quot;economy1.csv&quot;</span>, normalized_lst2, delimiter=<span class="string">&#x27;,&#x27;</span>,fmt = <span class="string">&#x27;%s&#x27;</span>)</span><br><span class="line">np.savetxt(<span class="string">&quot;温室气体排放1.csv&quot;</span>, normalized_lst3, delimiter=<span class="string">&#x27;,&#x27;</span>,fmt = <span class="string">&#x27;%s&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>用最小二乘法计算出三者之间的函数关系</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> curve_fit</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line">m=normalized_lst1</span><br><span class="line">n=normalized_lst2</span><br><span class="line">r=normalized_lst3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">model</span>(<span class="params">x, a, b, c</span>):</span><br><span class="line">    X, Y = x</span><br><span class="line">    <span class="keyword">return</span> a*X**<span class="number">5</span> + b*Y**<span class="number">2</span> + c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据集</span></span><br><span class="line">X = np.array(m)</span><br><span class="line">Y = np.array(n)</span><br><span class="line">Z = np.array(r)</span><br><span class="line"><span class="comment"># 将数据集合并为一个数组</span></span><br><span class="line">data = np.array([X, Y, Z])</span><br><span class="line"><span class="comment"># 利用最小二乘法拟合函数</span></span><br><span class="line">popt, pcov = curve_fit(model, (X,Y), Z)</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a:&#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(popt[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;b:&#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(popt[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c:&#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(popt[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure><h4 id="（2）数据可视化-4"><a href="#（2）数据可视化-4" class="headerlink" title="（2）数据可视化"></a>（2）数据可视化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D <span class="comment">#绘制3D图案</span></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line">m=normalized_lst1</span><br><span class="line">n=normalized_lst2</span><br><span class="line">r=normalized_lst3</span><br><span class="line"></span><br><span class="line">x_,y_ = np.meshgrid(m,n,indexing=<span class="string">&#x27;ij&#x27;</span>) <span class="comment">#调用numpy中的meshgrid函数，进行网格化操作</span></span><br><span class="line">z_ = -<span class="number">0.447</span>*x_**<span class="number">3</span> + <span class="number">1.036</span>*y_**<span class="number">2</span> + <span class="number">0.314</span>  <span class="comment"># 画图所要表现出来的主函数</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>), facecolor=<span class="string">&#x27;white&#x27;</span>) <span class="comment">#创建图片</span></span><br><span class="line">sub = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)<span class="comment"># 添加子图，</span></span><br><span class="line">surf = sub.plot_surface(z_, y_, x_, cmap=plt.cm.brg) <span class="comment">#绘制曲面,cmap=plt.cm.brg并设置颜色cmap</span></span><br><span class="line">cb = fig.colorbar(surf, shrink=<span class="number">0.5</span>, aspect=<span class="number">15</span>) <span class="comment">#设置颜色棒</span></span><br><span class="line">sub.set_xlabel(<span class="string">r&quot; emission&quot;</span>)</span><br><span class="line">sub.set_ylabel(<span class="string">r&quot; economy&quot;</span>)</span><br><span class="line">sub.set_zlabel(<span class="string">r&quot; total&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.10.png" alt="1.10"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D <span class="comment">#绘制3D图案</span></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line">m=normalized_lst1</span><br><span class="line">n=normalized_lst2</span><br><span class="line">r=normalized_lst3</span><br><span class="line"></span><br><span class="line">x_,y_ = np.meshgrid(m,n,indexing=<span class="string">&#x27;ij&#x27;</span>) <span class="comment">#调用numpy中的meshgrid函数，进行网格化操作</span></span><br><span class="line">z_ = -<span class="number">0.447</span>*x_**<span class="number">3</span> + <span class="number">1.036</span>*y_**<span class="number">2</span> + <span class="number">0.314</span>  <span class="comment"># 画图所要表现出来的主函数</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>), facecolor=<span class="string">&#x27;white&#x27;</span>) <span class="comment">#创建图片</span></span><br><span class="line">sub = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)<span class="comment"># 添加子图，</span></span><br><span class="line">surf = sub.plot_surface(z_, x_, y_, cmap=plt.cm.brg) <span class="comment">#绘制曲面,cmap=plt.cm.brg并设置颜色cmap</span></span><br><span class="line">cb = fig.colorbar(surf, shrink=<span class="number">0.5</span>, aspect=<span class="number">15</span>) <span class="comment">#设置颜色棒</span></span><br><span class="line">sub.set_xlabel(<span class="string">r&quot; emission&quot;</span>)</span><br><span class="line">sub.set_ylabel(<span class="string">r&quot; total&quot;</span>)</span><br><span class="line">sub.set_zlabel(<span class="string">r&quot; economy&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.11.png" alt="1.11"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D <span class="comment">#绘制3D图案</span></span><br><span class="line"><span class="comment"># 处理数据</span></span><br><span class="line">m=normalized_lst1</span><br><span class="line">n=normalized_lst2</span><br><span class="line">r=normalized_lst3</span><br><span class="line"></span><br><span class="line">x_,y_ = np.meshgrid(m,n,indexing=<span class="string">&#x27;ij&#x27;</span>) <span class="comment">#调用numpy中的meshgrid函数，进行网格化操作</span></span><br><span class="line">z_ = -<span class="number">0.447</span>*x_**<span class="number">3</span> + <span class="number">1.036</span>*y_**<span class="number">2</span> + <span class="number">0.314</span>  <span class="comment"># 画图所要表现出来的主函数</span></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>), facecolor=<span class="string">&#x27;white&#x27;</span>) <span class="comment">#创建图片</span></span><br><span class="line">sub = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">&#x27;3d&#x27;</span>)<span class="comment"># 添加子图，</span></span><br><span class="line">surf = sub.plot_surface(y_, x_, z_, cmap=plt.cm.brg) <span class="comment">#绘制曲面,cmap=plt.cm.brg并设置颜色cmap</span></span><br><span class="line">cb = fig.colorbar(surf, shrink=<span class="number">0.5</span>, aspect=<span class="number">15</span>) <span class="comment">#设置颜色棒</span></span><br><span class="line">sub.set_xlabel(<span class="string">r&quot; economy&quot;</span>)</span><br><span class="line">sub.set_ylabel(<span class="string">r&quot; total&quot;</span>)</span><br><span class="line">sub.set_zlabel(<span class="string">r&quot; emission&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.12.png" alt="1.12"></p><p>可以看到三者之间的大致关系，都是递增的趋势</p><h3 id="8-预测未来温度，碳排放量，经济趋势"><a href="#8-预测未来温度，碳排放量，经济趋势" class="headerlink" title="8.预测未来温度，碳排放量，经济趋势"></a>8.预测未来温度，碳排放量，经济趋势</h3><h4 id="（1）预测碳排放"><a href="#（1）预测碳排放" class="headerlink" title="（1）预测碳排放"></a>（1）预测碳排放</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"><span class="comment"># 1. 加载数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;/home/mw/project/温室气体排放.csv&#x27;</span>)</span><br><span class="line">X = np.array(df[[<span class="string">&#x27;Year&#x27;</span>]]) <span class="comment"># 选择年份作为特征值</span></span><br><span class="line">y = np.array(df[[<span class="string">&#x27;emission&#x27;</span>]]) <span class="comment"># 碳排放量作为目标值</span></span><br><span class="line"><span class="comment"># 2. 数据预处理</span></span><br><span class="line">max_val1 = np.array(<span class="built_in">max</span>(X))</span><br><span class="line">min_val1 = np.array(<span class="built_in">min</span>(X))</span><br><span class="line">max_val2 =np.array(<span class="built_in">max</span>(y))</span><br><span class="line">min_val2 = np.array(<span class="built_in">min</span>(y))</span><br><span class="line"><span class="comment"># 归一化处理</span></span><br><span class="line">X = [(x - min_val1) / (max_val1 - min_val1) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">y= [(x - min_val2) / (max_val2 - min_val2) <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line"><span class="comment"># 3. 训练集和测试集的划分</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>,random_state=<span class="number">0</span>)</span><br><span class="line">X=np.array(X)</span><br><span class="line">X_train=np.array(X_train)</span><br><span class="line">y_train=np.array(y_train)</span><br><span class="line">X_test=np.array(X_test)</span><br><span class="line">y_test=np.array(y_test)</span><br><span class="line"><span class="comment"># 4. 建立 MLP 模型并进行拟合</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">10</span>,input_dim=X.shape[<span class="number">1</span>],activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=Adam())</span><br><span class="line">model.fit(X_train, y_train, epochs=<span class="number">100</span>, batch_size=<span class="number">10</span>)</span><br><span class="line"><span class="comment">#使用测试集数据验证模型，并可视化预测结果：</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 5. 模型预测</span></span><br><span class="line"><span class="comment"># print(X_test,y_test)</span></span><br><span class="line">y_test_one=[<span class="number">0.01843818</span>,<span class="number">0.97830803</span>,<span class="number">0.28850325</span>,<span class="number">0.16052061</span>,<span class="number">0.96095445</span>,<span class="number">0.93058568</span>,<span class="number">0.88828633</span>]</span><br><span class="line">x_test_one=[<span class="number">0.06666667</span>,<span class="number">0.96666667</span>,<span class="number">0.43333333</span>,<span class="number">0.33333333</span>,<span class="number">0.9</span>,<span class="number">0.83333333</span>,<span class="number">0.73333333</span>]</span><br><span class="line">y_pred = model.predict(x_test_one)</span><br><span class="line">score = r2_score(y_test_one, y_pred)</span><br><span class="line"><span class="comment"># 6. 可视化预测结果</span></span><br><span class="line">x_axis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">plt.scatter(x_axis, y_test, color=<span class="string">&#x27;gray&#x27;</span>, alpha=<span class="number">0.2</span>)</span><br><span class="line">plt.plot(x_axis, y_pred, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;emission&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">f&#x27;R2 Score: <span class="subst">&#123;score:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>可以看到精度为0.96</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"><span class="comment"># 1. 加载数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;/home/mw/project/温室气体排放.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># X = np.array(df[[&#x27;Year&#x27;]]) # 选择年份作为特征值</span></span><br><span class="line">y = np.array(df[[<span class="string">&#x27;emission&#x27;</span>]]) <span class="comment"># 碳排放量作为目标值</span></span><br><span class="line">X=np.array([<span class="number">1991</span>,<span class="number">1992</span>,<span class="number">1993</span>,<span class="number">1994</span>,<span class="number">1995</span>,<span class="number">1996</span>,<span class="number">1997</span>,<span class="number">1998</span>,<span class="number">1999</span>,<span class="number">2000</span>,<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2005</span>,<span class="number">2006</span>,<span class="number">2007</span>,<span class="number">2008</span>,<span class="number">2009</span>,<span class="number">2010</span>,<span class="number">2011</span>,<span class="number">2012</span>,<span class="number">2013</span>,<span class="number">2014</span></span><br><span class="line">,<span class="number">2015</span>,<span class="number">2016</span>,<span class="number">2017</span>,<span class="number">2018</span>,<span class="number">2019</span>,<span class="number">2020</span>,<span class="number">2021</span>,<span class="number">2022</span>,<span class="number">2023</span>,<span class="number">2024</span>,<span class="number">2025</span>,<span class="number">2026</span>,<span class="number">2027</span>,<span class="number">2028</span>,<span class="number">2029</span>,<span class="number">2030</span>])</span><br><span class="line">X=X.reshape((<span class="number">40</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># print(X[31:40])</span></span><br><span class="line"><span class="comment"># 2. 数据预处理</span></span><br><span class="line">max_val1 = np.array(<span class="built_in">max</span>(X))</span><br><span class="line">min_val1 = np.array(<span class="built_in">min</span>(X))</span><br><span class="line">max_val2 =np.array(<span class="built_in">max</span>(y))</span><br><span class="line">min_val2 = np.array(<span class="built_in">min</span>(y))</span><br><span class="line"><span class="comment"># 归一化处理</span></span><br><span class="line">X = [(x - min_val1) / (max_val1 - min_val1) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">y= [(x - min_val2) / (max_val2 - min_val2) <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line"><span class="comment"># 3. 训练集和测试集的划分</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X[<span class="number">0</span>:<span class="number">31</span>], y, test_size=<span class="number">0.2</span>,random_state=<span class="number">0</span>)</span><br><span class="line">X=np.array(X)</span><br><span class="line">X_train=np.array(X_train)</span><br><span class="line">y_train=np.array(y_train)</span><br><span class="line">X_test=np.array(X_test)</span><br><span class="line">y_test=np.array(y_test)</span><br><span class="line"><span class="comment"># 4. 建立 MLP 模型并进行拟合</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">10</span>,input_dim=X.shape[<span class="number">1</span>],activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">10</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=Adam())</span><br><span class="line">model.fit(X_train, y_train, epochs=<span class="number">100</span>, batch_size=<span class="number">10</span>)</span><br><span class="line">y_pred = model.predict(X[<span class="number">31</span>:<span class="number">40</span>])</span><br><span class="line"><span class="built_in">print</span>(y_pred)</span><br><span class="line">rec_data = y_pred * (max_val2 - min_val2) + min_val2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;recovered data: &quot;</span>,<span class="string">&#x27;\n&#x27;</span>, rec_data)</span><br></pre></td></tr></table></figure><p><img src="/2023/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B8%BB%E9%A2%98%E8%B5%9B/1.13.png" alt="1.13"></p><p>由结果可知，在未来几年碳排放会达到峰值</p><h4 id="（2）预测未来经济"><a href="#（2）预测未来经济" class="headerlink" title="（2）预测未来经济"></a>（2）预测未来经济</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"><span class="comment"># 1. 加载数据</span></span><br><span class="line">X=np.array([<span class="number">2000</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2006</span>,<span class="number">2007</span>,<span class="number">2008</span>,<span class="number">2009</span>,<span class="number">2010</span>,<span class="number">2011</span>,<span class="number">2012</span>,<span class="number">2013</span>,<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2016</span>,<span class="number">2017</span>,<span class="number">2018</span>,<span class="number">2019</span>,<span class="number">2020</span>,<span class="number">2021</span>,<span class="number">2022</span>,<span class="number">2023</span>,<span class="number">2024</span>,<span class="number">2025</span>,<span class="number">2026</span>,<span class="number">2027</span>,<span class="number">2028</span>,<span class="number">2029</span>,<span class="number">2030</span>])</span><br><span class="line">X=X.reshape((<span class="number">29</span>, <span class="number">1</span>))</span><br><span class="line">y=np.array([<span class="number">11041</span>,<span class="number">11167</span>,<span class="number">12259</span>,<span class="number">15503</span>,<span class="number">16116</span>,<span class="number">16300</span>,<span class="number">16922</span>,<span class="number">17285</span>,<span class="number">18345</span>,<span class="number">19564</span>,<span class="number">20213</span>,<span class="number">21280</span>,<span class="number">22405</span>,<span class="number">23244</span>,<span class="number">24307</span>,<span class="number">25821</span>,<span class="number">26840</span>,<span class="number">30178</span>,<span class="number">35765</span>,<span class="number">40084</span>,<span class="number">41459</span>])</span><br><span class="line">y=y.reshape((<span class="number">21</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数据预处理</span></span><br><span class="line">max_val1 = np.array(<span class="built_in">max</span>(X))</span><br><span class="line">min_val1 = np.array(<span class="built_in">min</span>(X))</span><br><span class="line">max_val2 =np.array(<span class="built_in">max</span>(y))</span><br><span class="line">min_val2 = np.array(<span class="built_in">min</span>(y))</span><br><span class="line"><span class="comment"># 归一化处理</span></span><br><span class="line">X = [(x - min_val1) / (max_val1 - min_val1) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">y= [(x - min_val2) / (max_val2 - min_val2) <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line"><span class="comment"># 3. 训练集和测试集的划分</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X[<span class="number">0</span>:<span class="number">21</span>], y, test_size=<span class="number">0.2</span>,random_state=<span class="number">0</span>)</span><br><span class="line">X=np.array(X)</span><br><span class="line">X_train=np.array(X_train)</span><br><span class="line">y_train=np.array(y_train)</span><br><span class="line">X_test=np.array(X_test)</span><br><span class="line">y_test=np.array(y_test)</span><br><span class="line"><span class="comment"># 4. 建立 MLP 模型并进行拟合</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">30</span>,input_dim=X.shape[<span class="number">1</span>],activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">30</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=Adam())</span><br><span class="line">model.fit(X_train, y_train, epochs=<span class="number">400</span>, batch_size=<span class="number">10</span>)</span><br><span class="line"><span class="comment">#使用测试集数据验证模型，并可视化预测结果：</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 5. 模型预测</span></span><br><span class="line"><span class="comment"># print(X_test,y_test)</span></span><br><span class="line">y_test_one= [<span class="number">0.24012098</span>,<span class="number">0.40117693</span>,<span class="number">1.0</span>,<span class="number">0.00414228</span>,<span class="number">0.3366099</span> ]</span><br><span class="line">x_test_one=[<span class="number">0.33333333</span>,<span class="number">0.5</span> ,<span class="number">0.73333333</span>,<span class="number">0.06666667</span>,<span class="number">0.43333333</span>]</span><br><span class="line">y_pred = model.predict(x_test_one)</span><br><span class="line">score = r2_score(y_test_one, y_pred)</span><br><span class="line"><span class="comment"># 6. 可视化预测结果</span></span><br><span class="line">x_axis=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">plt.scatter(x_axis, y_test, color=<span class="string">&#x27;gray&#x27;</span>, alpha=<span class="number">0.2</span>)</span><br><span class="line">plt.plot(x_axis, y_pred, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Year&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Total&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">f&#x27;R2 Score: <span class="subst">&#123;score:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="（3）预测未来濒危物种"><a href="#（3）预测未来濒危物种" class="headerlink" title="（3）预测未来濒危物种"></a>（3）预测未来濒危物种</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"><span class="comment"># 1. 加载数据</span></span><br><span class="line">X=np.array([<span class="number">2000</span>,<span class="number">2002</span>,<span class="number">2003</span>,<span class="number">2004</span>,<span class="number">2006</span>,<span class="number">2007</span>,<span class="number">2008</span>,<span class="number">2009</span>,<span class="number">2010</span>,<span class="number">2011</span>,<span class="number">2012</span>,<span class="number">2013</span>,<span class="number">2014</span>,<span class="number">2015</span>,<span class="number">2016</span>,<span class="number">2017</span>,<span class="number">2018</span>,<span class="number">2019</span>,<span class="number">2020</span>,<span class="number">2021</span>,<span class="number">2022</span>,<span class="number">2023</span>,<span class="number">2024</span>,<span class="number">2025</span>,<span class="number">2026</span>,<span class="number">2027</span>,<span class="number">2028</span>,<span class="number">2029</span>,<span class="number">2030</span>])</span><br><span class="line">X=X.reshape((<span class="number">29</span>, <span class="number">1</span>))          <span class="comment"># 选择年份作为特征值</span></span><br><span class="line">y=np.array([<span class="number">11041</span>,<span class="number">11167</span>,<span class="number">12259</span>,<span class="number">15503</span>,<span class="number">16116</span>,<span class="number">16300</span>,<span class="number">16922</span>,<span class="number">17285</span>,<span class="number">18345</span>,<span class="number">19564</span>,<span class="number">20213</span>,<span class="number">21280</span>,<span class="number">22405</span>,<span class="number">23244</span>,<span class="number">24307</span>,<span class="number">25821</span>,<span class="number">26840</span>,<span class="number">30178</span>,<span class="number">35765</span>,<span class="number">40084</span>,<span class="number">41459</span>])</span><br><span class="line">y=y.reshape((<span class="number">21</span>, <span class="number">1</span>))          <span class="comment"># 濒危物种数量作为目标值</span></span><br><span class="line"><span class="comment"># 2. 数据预处理</span></span><br><span class="line">max_val1 = np.array(<span class="built_in">max</span>(X))</span><br><span class="line">min_val1 = np.array(<span class="built_in">min</span>(X))</span><br><span class="line">max_val2 =np.array(<span class="built_in">max</span>(y))</span><br><span class="line">min_val2 = np.array(<span class="built_in">min</span>(y))</span><br><span class="line"><span class="comment"># 归一化处理</span></span><br><span class="line">X = [(x - min_val1) / (max_val1 - min_val1) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">y= [(x - min_val2) / (max_val2 - min_val2) <span class="keyword">for</span> x <span class="keyword">in</span> y]</span><br><span class="line"><span class="comment"># 3. 训练集和测试集的划分</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X[<span class="number">0</span>:<span class="number">21</span>], y, test_size=<span class="number">0.2</span>,random_state=<span class="number">0</span>)</span><br><span class="line">X=np.array(X)</span><br><span class="line">X_train=np.array(X_train)</span><br><span class="line">y_train=np.array(y_train)</span><br><span class="line">X_test=np.array(X_test)</span><br><span class="line">y_test=np.array(y_test)</span><br><span class="line"><span class="comment"># 4. 建立 MLP 模型并进行拟合</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">30</span>,input_dim=X.shape[<span class="number">1</span>],activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">30</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">model.add(Dense(<span class="number">1</span>))</span><br><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=Adam())</span><br><span class="line">model.fit(X_train, y_train, epochs=<span class="number">400</span>, batch_size=<span class="number">10</span>)</span><br><span class="line">y_pred = model.predict(X[<span class="number">21</span>:<span class="number">29</span>])</span><br><span class="line"><span class="built_in">print</span>(y_pred)</span><br><span class="line">rec_data = y_pred * (max_val2 - min_val2) + min_val2</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;recovered data: &quot;</span>,<span class="string">&#x27;\n&#x27;</span>, rec_data)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机设计大赛，数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数1800每题知识点总结</title>
      <link href="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="一、函数、极限、连续"><a href="#一、函数、极限、连续" class="headerlink" title="一、函数、极限、连续"></a>一、函数、极限、连续</h3><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.1.jpg" alt="1.1"></p><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.2.jpg" alt="1.2"></p><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.3.jpg" alt="1.3"></p><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.4.jpg" alt="1.4"></p><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.5.jpg" alt="1.5"></p><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.6.jpg" alt="1.6"></p><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/1.7.jpg" alt="1.7"></p><h3 id="二、导数与微分"><a href="#二、导数与微分" class="headerlink" title="二、导数与微分"></a>二、导数与微分</h3><h3 id="三、中值定理与一元函数微分学的应用"><a href="#三、中值定理与一元函数微分学的应用" class="headerlink" title="三、中值定理与一元函数微分学的应用"></a>三、中值定理与一元函数微分学的应用</h3><h3 id="四、不定积分"><a href="#四、不定积分" class="headerlink" title="四、不定积分"></a>四、不定积分</h3><h3 id><a href="#" class="headerlink" title></a><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/4.1.jpg" alt="4.1"></h3><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/4.5.jpg" alt="4.5"></p><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/4.2.jpg" alt="4.2"></p><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/4.3.jpg" alt="4.3"></p><p><img src="/2023/03/31/%E9%AB%98%E6%95%B01800%E6%AF%8F%E9%A2%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/4.4.jpg" alt="4.4"></p><h3 id="五、定积分及应用"><a href="#五、定积分及应用" class="headerlink" title="五、定积分及应用"></a>五、定积分及应用</h3><h3 id="六、多元函数微分学"><a href="#六、多元函数微分学" class="headerlink" title="六、多元函数微分学"></a>六、多元函数微分学</h3><h3 id="七、重积分"><a href="#七、重积分" class="headerlink" title="七、重积分"></a>七、重积分</h3><h3 id="八、微分方程"><a href="#八、微分方程" class="headerlink" title="八、微分方程"></a>八、微分方程</h3>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 1800每题知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计组第二章</title>
      <link href="/2023/03/31/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2023/03/31/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-第二章-x3D-x3D"><a href="#x3D-x3D-第二章-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第二章&#x3D;&#x3D;"></a>&#x3D;&#x3D;第二章&#x3D;&#x3D;</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/2023/03/31/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.1.jpg" alt="1.1"></p><p><img src="/2023/03/31/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.2.jpg" alt="1.2"></p><p><img src="/2023/03/31/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.3.jpg" alt="1.3"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第六章</title>
      <link href="/2023/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>/2023/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-第六章图-x3D-x3D"><a href="#x3D-x3D-第六章图-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第六章图&#x3D;&#x3D;"></a>&#x3D;&#x3D;第六章图&#x3D;&#x3D;</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2023/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E7%AB%A0/1.1.jpg" alt="1.1"></h4>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第八讲</title>
      <link href="/2023/03/31/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%85%AB%E8%AE%B2/"/>
      <url>/2023/03/31/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%85%AB%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高数第七讲</title>
      <link href="/2023/03/31/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%83%E8%AE%B2/"/>
      <url>/2023/03/31/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%83%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高数第六讲</title>
      <link href="/2023/03/31/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%85%AD%E8%AE%B2/"/>
      <url>/2023/03/31/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%85%AD%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-基础知识-x3D-x3D"><a href="#x3D-x3D-基础知识-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基础知识&#x3D;&#x3D;"></a>&#x3D;&#x3D;基础知识&#x3D;&#x3D;</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2023/03/31/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%85%AD%E8%AE%B2/1.1.jpg" alt="1.1"></h4><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 中值定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数1800</title>
      <link href="/2023/03/18/%E9%AB%98%E6%95%B01800/"/>
      <url>/2023/03/18/%E9%AB%98%E6%95%B01800/</url>
      
        <content type="html"><![CDATA[<h3 id="一、函数、极限、连续"><a href="#一、函数、极限、连续" class="headerlink" title="一、函数、极限、连续"></a>一、函数、极限、连续</h3><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/1.1.jpg" alt="1.1"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/1.2.jpg" alt="1.2"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/1.3.jpg" alt="1.3"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/1.4.jpg" alt="1.4"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/1.5.jpg" alt="1.5"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/1.6.jpg" alt="1.6"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/1.7.jpg" alt="1.7"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/1.8.jpg" alt="1.8"></p><h3 id="二、导数与微分"><a href="#二、导数与微分" class="headerlink" title="二、导数与微分"></a>二、导数与微分</h3><h3 id="三、中值定理与一元函数微分学的应用"><a href="#三、中值定理与一元函数微分学的应用" class="headerlink" title="三、中值定理与一元函数微分学的应用"></a>三、中值定理与一元函数微分学的应用</h3><h3 id="四、不定积分"><a href="#四、不定积分" class="headerlink" title="四、不定积分"></a>四、不定积分</h3><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/4.1.jpg" alt="4.1"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/4.2.jpg" alt="4.1"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/4.3.jpg" alt="4.1"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/4.4.jpg" alt="4.1"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/4.5.jpg" alt="4.1"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/4.6.jpg" alt="4.1"></p><p><img src="/2023/03/18/%E9%AB%98%E6%95%B01800/4.7.jpg" alt="4.1"></p><h3 id="五、定积分及应用"><a href="#五、定积分及应用" class="headerlink" title="五、定积分及应用"></a>五、定积分及应用</h3><h3 id="六、多元函数微分学"><a href="#六、多元函数微分学" class="headerlink" title="六、多元函数微分学"></a>六、多元函数微分学</h3><h3 id="七、重积分"><a href="#七、重积分" class="headerlink" title="七、重积分"></a>七、重积分</h3><h3 id="八、微分方程"><a href="#八、微分方程" class="headerlink" title="八、微分方程"></a>八、微分方程</h3>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 1800标记题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第五章</title>
      <link href="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-第五章树与二叉树-x3D-x3D"><a href="#x3D-x3D-第五章树与二叉树-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第五章树与二叉树&#x3D;&#x3D;"></a>&#x3D;&#x3D;第五章树与二叉树&#x3D;&#x3D;</h2><h3 id="5-1树的基本概念"><a href="#5-1树的基本概念" class="headerlink" title="5.1树的基本概念"></a>5.1树的基本概念</h3><h4 id="5-1-1树的定义"><a href="#5-1-1树的定义" class="headerlink" title="5.1.1树的定义"></a>5.1.1树的定义</h4><p>树是一种<strong>递归定义</strong>的数据结构</p><h4 id="5-1-2基本术语"><a href="#5-1-2基本术语" class="headerlink" title="5.1.2基本术语"></a>5.1.2基本术语</h4><p><strong>节点之间的关系描述</strong></p><p><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.1.png" alt="1.1"></p><p>什么是两个节点之间的路径？这个路径只能从下往上</p><p>什么是路径长度？经过几条边</p><p><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.2.png" alt="1.2"></p><p>有序树 VS 无序树：具体要看你用树存什么，是否需要用节点的左右位置反映某些逻辑结构</p><p>森林——eg：全中国所有人家的家谱</p><p>森林也可以有0棵树，空森林。</p><h4 id="5-1-3树的性质"><a href="#5-1-3树的性质" class="headerlink" title="5.1.3树的性质"></a>5.1.3树的性质</h4><p>节点数&#x3D;总度数+1</p><p><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.3.png" alt="1.3"></p><p><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.4.png" alt="1.4"></p><p><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.5.png" alt="1.5"></p><p><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.6.png" alt="1.6"></p><p><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.7.png" alt="1.7"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>因为最近找到了上课老师讲课的ppt，发现直接在课件上记笔记更加方便，所以以后只放总结。</p><h3 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h3><h4 id><a href="#" class="headerlink" title></a><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.8.jpg" alt="1.8"></h4><p><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.9.jpg" alt="1.9"></p><p><img src="/2023/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E7%AB%A0/1.10.jpg" alt="1.10"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树与二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第四章</title>
      <link href="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-第四章串-x3D-x3D"><a href="#x3D-x3D-第四章串-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第四章串&#x3D;&#x3D;"></a>&#x3D;&#x3D;第四章串&#x3D;&#x3D;</h2><h3 id="4-1串的定义和实现"><a href="#4-1串的定义和实现" class="headerlink" title="4.1串的定义和实现"></a>4.1串的定义和实现</h3><h4 id="4-1-1串的定义"><a href="#4-1-1串的定义" class="headerlink" title="4.1.1串的定义"></a>4.1.1串的定义</h4><p>王道书中——单引号括起来的字符序列是串的值，但是有的地方是用双引号（Java、C）有的地方是用单引号（Python）</p><p>字符串只是边界值</p><p>字符在主串中的位置，下标从1开始，和<strong>线性表中的位序</strong>一样。</p><p>空串 VS 空格串，其中空格串中每个空格符占1B（一个字节&#x3D;8个二进制位）</p><p><strong>通常以“子串”为增删改查操作对象</strong></p><h4 id="4-1-2串的存储类型"><a href="#4-1-2串的存储类型" class="headerlink" title="4.1.2串的存储类型"></a>4.1.2串的存储类型</h4><p>串和线性表类似</p><p>在线性表中，我们使用的是ElemType，在串中我们可以使用char</p><p><strong>串的顺序存储</strong></p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.1.png" alt="1.1"></p><p>串的顺序存储优缺点可以结合顺序表的知识思考优缺点</p><p>其中第一个不是从1开始的，第二个char[0]会占1B存储空间，第三个找到\0还需要遍历，最后一个比较好。</p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.2.png" alt="1.2"></p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.3.png" alt="1.3"></p><p>串的链式存储优缺点可以结合链表知识思考优缺点</p><p><strong>基本操作的实现</strong></p><p>（1）求子串</p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.4.png" alt="1.4"></p><p>（2）比较两个串的大小</p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.5.png" alt="1.5"></p><p>（3）定位操作</p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.6.png" alt="1.6"></p><h4 id="4-1-3串的基本操作"><a href="#4-1-3串的基本操作" class="headerlink" title="4.1.3串的基本操作"></a>4.1.3串的基本操作</h4><p>串的比较操作：从第一个字符开始往后依次对比，先出现更大字符的串就更大</p><p>任何数据保存到计算机中一定是二进制数，所以对比时直接对比二进制数。</p><p>基于同一个字符集，可以有多种编码方案：UTF-8、UTF-16</p><p>拓展：乱码问题</p><p>主要是解码不同，</p><h3 id="4-2串的模式匹配"><a href="#4-2串的模式匹配" class="headerlink" title="4.2串的模式匹配"></a>4.2串的模式匹配</h3><h4 id="4-2-1简单的模式匹配算法"><a href="#4-2-1简单的模式匹配算法" class="headerlink" title="4.2.1简单的模式匹配算法"></a>4.2.1简单的模式匹配算法</h4><p>子串——主串的一部分，一定存在</p><p>模式串——不一定能在主串中找到</p><p><strong>朴素模式匹配算法——暴力求解</strong></p><p>主串长度为n，模式串长度为m</p><p>其中最多对比n-m+1个子串</p><p>Index(S,T)就是模式匹配算法</p><p><strong>接下来，不使用字符串的基本操作，直接通过数组下标实现朴素模式匹配算法</strong></p><p>代码见课本，最坏的情况：每个子串都要对比m个字符，共n-m+1个子串，复杂度&#x3D;O((n-m+1)m)&#x3D;O(nm)  （注：很多时候n&gt;&gt;m）</p><h4 id="4-2-2串的模式匹配算法——KMP算法"><a href="#4-2-2串的模式匹配算法——KMP算法" class="headerlink" title="4.2.2串的模式匹配算法——KMP算法"></a>4.2.2串的模式匹配算法——KMP算法</h4><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.7.png" alt="1.7"></p><p>不匹配的字符之前，一定是和模式串一致的</p><p>优化后主串指针不“回溯”</p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.8.png" alt="1.8"></p><p>next数组：next数组只和短短的模式串有关，和长长的主串无关</p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.9.png" alt="1.9"></p><p>详细代码见课本P113页</p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.10.png" alt="1.10"></p><p>朴素模式算法——匹配失败时，主串指针i疯狂回溯，最坏时间复杂度：O(mn)</p><p>KMP算法——匹配失败时，主串指针i不回溯，最坏时间复杂度：O(m+n)，其中求next数组时间复杂度为O(m)，模式匹配过程最坏时间复杂度O(n)</p><p><strong>求next数组：</strong></p><p>next[0]无脑写0，next[1]无脑写1</p><h4 id="4-2-3KMP算法的进一步优化"><a href="#4-2-3KMP算法的进一步优化" class="headerlink" title="4.2.3KMP算法的进一步优化"></a>4.2.3KMP算法的进一步优化</h4><p>KMP算法的优化本质上只是优化的next数组</p><p><img src="/2023/03/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E7%AB%A0/1.11.png" alt="1.11"></p><p>求nextval数组：手算解题，先求出next数组，再由next数组求出nextval数组</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣</title>
      <link href="/2023/03/10/%E5%8A%9B%E6%89%A3/"/>
      <url>/2023/03/10/%E5%8A%9B%E6%89%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-23-x2F-3-x3D-x3D"><a href="#x3D-x3D-23-x2F-3-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;23&#x2F;3&#x3D;&#x3D;"></a>&#x3D;&#x3D;23&#x2F;3&#x3D;&#x3D;</h3><h4 id="1-（26-）删除数组中的重复项——2023-x2F-3-x2F-10"><a href="#1-（26-）删除数组中的重复项——2023-x2F-3-x2F-10" class="headerlink" title="1.（26.）删除数组中的重复项——2023&#x2F;3&#x2F;10"></a>1.（26.）删除数组中的重复项——2023&#x2F;3&#x2F;10</h4><p>算法思想：比如说nums为：1 2 2 3 5 7 8 8 9，因为数组是升序排列的，所以我们可以遍历数组把大于前面元素的前移，从而实现把相同元素去掉。</p><p>或者可以用快慢指针做，一个慢指针就是输出数组，一个快指针是指向原数组的元素</p><p><img src="/2023/03/10/%E5%8A%9B%E6%89%A3/1.1.png" alt="1.1"></p><p>图片来自力扣：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solution/shuang-zhi-zhen-shan-chu-zhong-fu-xiang-dai-you-hu/</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pre=nums[<span class="number">0</span>];<span class="comment">//</span></span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numsSize;i++) &#123;</span><br><span class="line">        pre = nums[cur];</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; pre) &#123;</span><br><span class="line">            nums[++cur] = nums[i];  <span class="comment">//直接从第二个元素开始查找替换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快慢指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">//慢指针</span></span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>; <span class="comment">//快指针</span></span><br><span class="line">    <span class="keyword">while</span> (q &lt; numsSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[p] != nums[q]) &#123;</span><br><span class="line">            nums[p+<span class="number">1</span>] = nums[q]; <span class="comment">//若不相等，将快指针的值赋值给慢指针后一位</span></span><br><span class="line">            p++;  <span class="comment">//有一个不一样的就往后加1个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        q++;  <span class="comment">//快指针一直往后查询</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums</span>):</span><br><span class="line">        index=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i-<span class="number">1</span>]:</span><br><span class="line">                nums[index] =nums[i]; <span class="comment">#相当于将不相等的元素提取出来，重新覆盖了一样</span></span><br><span class="line">                index += <span class="number">1</span>;  <span class="comment">#多一个不相等的元素,index就加1</span></span><br><span class="line">        <span class="keyword">return</span> index;</span><br></pre></td></tr></table></figure><p>感受：本题中可以用快慢指针做，一个指针是指向结果数组，另一个是在原来数组中查找不相等的值，相当于在原表上进行操作。思想都是一样的，查找不同的元素，之后前移。</p><h4 id="2-（27-）移除元素——2023-x2F-3-x2F-11"><a href="#2-（27-）移除元素——2023-x2F-3-x2F-11" class="headerlink" title="2.（27.）移除元素——2023&#x2F;3&#x2F;11"></a>2.（27.）移除元素——2023&#x2F;3&#x2F;11</h4><p>算法思想：可以用双指针法，一个指针查看数组元素，另一个元素来确定最终数组的元素。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;numsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != val)&#123;</span><br><span class="line">            nums[k] = nums[i];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums, val</span>):</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != val:  <span class="comment">#如果不相等，就把值赋给k</span></span><br><span class="line">                nums[k] = nums[i];</span><br><span class="line">                k += <span class="number">1</span>;     <span class="comment">#多了一个元素k就加1</span></span><br><span class="line">        <span class="keyword">return</span> k;</span><br></pre></td></tr></table></figure><p>今天的题目很简单，再接再厉！</p><h4 id="3-（1-）两数之和——2023-x2F-3-x2F-12"><a href="#3-（1-）两数之和——2023-x2F-3-x2F-12" class="headerlink" title="3.（1.）两数之和——2023&#x2F;3&#x2F;12"></a>3.（1.）两数之和——2023&#x2F;3&#x2F;12</h4><p>算法思想：可以用两个指针遍历数组，若是两个指针所指元素为target值，则返回所知元素的位置。还可以使用哈希表，等后面数据结构学完之后再过来写一下。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    *returnSize = <span class="number">0</span>;<span class="comment">//返回数组长度为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=numsSize<span class="number">-1</span>;j&gt;i;j--)&#123;<span class="comment">//两个指针一块遍历数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                nums[<span class="number">0</span>] = i;</span><br><span class="line">                nums[<span class="number">1</span>] = j;</span><br><span class="line">                *returnSize = <span class="number">2</span>;<span class="comment">//将返回数组的长度改为2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i,j];</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h4 id="4-（66-）加一——2023-x2F-3-x2F-13"><a href="#4-（66-）加一——2023-x2F-3-x2F-13" class="headerlink" title="4.（66.）加一——2023&#x2F;3&#x2F;13"></a>4.（66.）加一——2023&#x2F;3&#x2F;13</h4><p>算法思想：题中要求将非空数组加一之后返回数组，可以分情况讨论，我们只需要判断每个位置上的元素+1之后模10之后是否为0，只有为0的数，则该数为9，这块的循环是逆序进行的，从最后一个位置元素开始遍历，只要等于0，就看前一个元素令其+1，知道遇到不为零的情况，返回该数组，例如：1，2，9。会返回1，3，0。最后一个是9+1&#x3D;10&#x3D;0，前一个2+1&#x3D;3≠0，返回数组。若是遇到9，9，9.则会重新创建一个数组（长度为digitsSize+1），将第一位赋值为1，其他为0。</p><p>memset函数：该函数是初始化函数，作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">plusOne</span><span class="params">(<span class="type">int</span>* digits, <span class="type">int</span> digitsSize, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=digitsSize<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        digits[i]=(digits[i]+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(digits[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            *returnSize=digitsSize;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize=digitsSize+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> *res = (<span class="type">int</span> *)<span class="built_in">malloc</span>((digitsSize+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(res==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(res,<span class="number">0</span>,(digitsSize+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">//令数组中的值都为0</span></span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">//令第一个位置元素为1</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">plusOne</span>(<span class="params">self, digits</span>):</span><br><span class="line">        i=<span class="number">1</span>;</span><br><span class="line">        n=<span class="built_in">len</span>(digits);</span><br><span class="line">        <span class="keyword">while</span> i&lt;=n:</span><br><span class="line">            digits[-i]+=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> digits[-i] == <span class="number">10</span>:</span><br><span class="line">                digits[-i]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> i==n:</span><br><span class="line">                    digits.insert(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">                i+=<span class="number">1</span>; <span class="comment">#向前遍历</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br></pre></td></tr></table></figure><h4 id="5-（88-）合并两个有序数组——2023-x2F-3-x2F-14"><a href="#5-（88-）合并两个有序数组——2023-x2F-3-x2F-14" class="headerlink" title="5.（88.）合并两个有序数组——2023&#x2F;3&#x2F;14"></a>5.（88.）合并两个有序数组——2023&#x2F;3&#x2F;14</h4><p>算法思想：目前想到两种方法，一种可以先将nums2中的元素加到nums1中，之后在排序。第二种，可以用双指针，一边插入一边排序。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span> m, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>;  <span class="comment">//双指针</span></span><br><span class="line">    <span class="type">int</span> sorted[m+n]; <span class="comment">//定义一个数组长度为m+n</span></span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    <span class="keyword">while</span>(p1&lt;m || p2&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==m)&#123;  <span class="comment">//p1为空数组，或者是排序完成之后剩下都是p2的元素</span></span><br><span class="line">            cur=nums2[p2++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2==n)&#123;  <span class="comment">//p2为空数组，或者是排序完成之后剩下都是p1的元素</span></span><br><span class="line">            cur=nums1[p1++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[p1]&lt;nums2[p2])&#123; <span class="comment">//比较两元素的元素哪个大输出哪个</span></span><br><span class="line">            cur=nums1[p1++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur=nums2[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        sorted[p1+p2<span class="number">-1</span>]=cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i != m+n;i++)&#123;</span><br><span class="line">        nums1[i]=sorted[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#算法思想和c的一致</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, nums1, m, nums2, n</span>):</span><br><span class="line">        <span class="built_in">sorted</span>=[]</span><br><span class="line">        p1,p2=<span class="number">0</span>,<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> p1&lt;m <span class="keyword">or</span> p2&lt;n:</span><br><span class="line">            <span class="keyword">if</span> p1==m:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums2[p2])</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> p2==n:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums1[p1])</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[p1]&lt;nums2[p2]:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums1[p1])</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">sorted</span>.append(nums2[p2])</span><br><span class="line">                p2+=<span class="number">1</span></span><br><span class="line">        nums1[:]=<span class="built_in">sorted</span></span><br></pre></td></tr></table></figure><h4 id="6-（108-）杨辉三角——2023-x2F-3-x2F-15"><a href="#6-（108-）杨辉三角——2023-x2F-3-x2F-15" class="headerlink" title="6.（108.）杨辉三角——2023&#x2F;3&#x2F;15"></a>6.（108.）杨辉三角——2023&#x2F;3&#x2F;15</h4><p>算法思想：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>** <span class="title function_">generate</span><span class="params">(<span class="type">int</span> numRows, <span class="type">int</span>* returnSize, <span class="type">int</span>** returnColumnSizes)</span>&#123;</span><br><span class="line">    *returnColumnSizes=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *)*<span class="number">30</span>);</span><br><span class="line">    *returnSize=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> **ans=(<span class="type">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *)*<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">        (*returnSize)++;</span><br><span class="line">        (*returnColumnSizes)[i]=count;</span><br><span class="line">        ans[i]=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*count);</span><br><span class="line">        ans[i][<span class="number">0</span>]=<span class="number">1</span>,ans[i][count<span class="number">-1</span>]=<span class="number">1</span>;      <span class="comment">//每行第一个和最后一个值为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=count<span class="number">-2</span>;j++)&#123;</span><br><span class="line">            ans[i][j]=ans[i<span class="number">-1</span>][j<span class="number">-1</span>]+ans[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, numRows</span>):</span><br><span class="line">        ret=<span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numRows):</span><br><span class="line">            row=<span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,i+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j==<span class="number">0</span> <span class="keyword">or</span> j==i:</span><br><span class="line">                    row.append(<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    row.append(ret[i-<span class="number">1</span>][j]+ret[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">            ret.append(row)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><h4 id="7-（119-）杨辉三角Ⅱ——2023-x2F-3-x2F-16"><a href="#7-（119-）杨辉三角Ⅱ——2023-x2F-3-x2F-16" class="headerlink" title="7.（119.）杨辉三角Ⅱ——2023&#x2F;3&#x2F;16"></a>7.（119.）杨辉三角Ⅱ——2023&#x2F;3&#x2F;16</h4><p>算法思想：根据杨辉三角形的性质，每行第一个和最后一个元素为1，当前行第 <em>i</em> 项的计算只与上一行的第 i−1项及第 i 项有关，写出关系时即可。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">getRow</span><span class="params">(<span class="type">int</span> rowIndex, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    *returnSize = rowIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* a[rowIndex + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (i + <span class="number">1</span>));</span><br><span class="line">        a[i][<span class="number">0</span>] = a[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            a[i][j] = a[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[rowIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-（121-）买卖股票的最佳时机——2023-x2F-3-x2F-17"><a href="#8-（121-）买卖股票的最佳时机——2023-x2F-3-x2F-17" class="headerlink" title="8.（121.）买卖股票的最佳时机——2023&#x2F;3&#x2F;17"></a>8.（121.）买卖股票的最佳时机——2023&#x2F;3&#x2F;17</h4><p>算法思想：因为买股票只能在卖股票之前，我们要计算的是差值最大即利润最高的时候，prices[0]记为买股票的那天，res记成最大利润，之后for循环遍历数组，若后面比他大，就比较差值和res，把最大的赋值给res，若是比他小则交换。循环进行，直至结束。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,buy=prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;pricesSize;i++)&#123;</span><br><span class="line">        <span class="type">int</span> current=prices[i];</span><br><span class="line">        <span class="keyword">if</span>(buy&lt;=current &amp;&amp; current-buy&gt;=res)&#123;</span><br><span class="line">            res=current-buy;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (buy&gt;current)&#123;</span><br><span class="line">            buy=current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices</span>):</span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        self=prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(prices)):</span><br><span class="line">            <span class="keyword">if</span>(self&lt;prices[i]):</span><br><span class="line">                res=<span class="built_in">max</span>(res,prices[i]-self)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self=prices[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="9-（136-）只出现一次的数字——2023-x2F-3-x2F-18"><a href="#9-（136-）只出现一次的数字——2023-x2F-3-x2F-18" class="headerlink" title="9.（136.）只出现一次的数字——2023&#x2F;3&#x2F;18"></a>9.（136.）只出现一次的数字——2023&#x2F;3&#x2F;18</h4><p>算法思想：给出一个数组让找出只出现一次的数字，可以用异或的思想，因为异或满足交换律，同值取0，异值取1。而且0^a&#x3D;a，</p><p>就像[2，3，2，3，5]循环中的操作为2 ^ 3 ^ 2 ^ 3 ^ 5&#x3D;2 ^ 2 ^ 3 ^ 3 ^ 5&#x3D;0 ^ 0 ^ 5&#x3D;5</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        nums[<span class="number">0</span>]^=nums[i+<span class="number">1</span>]; <span class="comment">//nums[0]^nums[1]^nums[2]...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">singleNumber</span>(<span class="params">self, nums</span>):</span><br><span class="line">        a=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            a=a^num</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h4 id="10-（169-）多数元素——2023-x2F-3-x2F-19"><a href="#10-（169-）多数元素——2023-x2F-3-x2F-19" class="headerlink" title="10.（169.）多数元素——2023&#x2F;3&#x2F;19"></a>10.（169.）多数元素——2023&#x2F;3&#x2F;19</h4><p>算法思想：可以运用摩尔投票法的思想，假设第一个是超过一半的数，定义一个变量count来统计，如果后面遇到相同的数则count++,若是遇到不同的数则count–，这样最后肯定是超过一半的那个数，而且题中也说了，总是存在多数元素。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            res=nums[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res==nums[i]?count++:count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python中我们可以直接用内置函数排序之后，取中位数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">majorityElement</span>(<span class="params">self, nums</span>):</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="built_in">len</span>(nums) // <span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="？-11-（217-）存在重复元素——2023-x2F-3-x2F-20"><a href="#？-11-（217-）存在重复元素——2023-x2F-3-x2F-20" class="headerlink" title="？ 11.（217.）存在重复元素——2023&#x2F;3&#x2F;20"></a>？ 11.（217.）存在重复元素——2023&#x2F;3&#x2F;20</h4><p>算法思想：一开始想的是暴力求解，用两个for循环，但是超时了。后来看题解可以用快排，之后比较相邻元素，或者用哈希表做。python可以用内置函数set，去重之后比较长度即可。（快排数据结构还没有复习到，等到那块再过来看一下）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* _a, <span class="type">const</span> <span class="type">void</span>* _b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = *(<span class="type">int</span>*)_a, b = *(<span class="type">int</span>*)_b;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">set</span>(nums))&lt;<span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><h4 id="12-（258-）各位相加——2023-x2F-3-x2F-20"><a href="#12-（258-）各位相加——2023-x2F-3-x2F-20" class="headerlink" title="12.（258.）各位相加——2023&#x2F;3&#x2F;20"></a>12.（258.）各位相加——2023&#x2F;3&#x2F;20</h4><p>算法思想：根据取模等运算，将各个位置上的数取出来相加。while循环中，若是个位数，循环进行一次即可，若是大于10的数，循环可能要进行多次。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">addDigits</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(num&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=num%<span class="number">10</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addDigits</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="keyword">while</span> num &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> num:</span><br><span class="line">                <span class="built_in">sum</span> += num % <span class="number">10</span></span><br><span class="line">                num //= <span class="number">10</span></span><br><span class="line">            num = <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法，力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析</title>
      <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="系统认识数据分析"><a href="#系统认识数据分析" class="headerlink" title="系统认识数据分析"></a>系统认识数据分析</h3><h4 id="1-观测"><a href="#1-观测" class="headerlink" title="1.观测"></a>1.观测</h4><p><strong>观察：</strong>采集数据、储存数据、展示数据</p><p><strong>（1）采集数据：</strong></p><p>解析系统日志、埋点获取新数据、通过传感器采集、爬虫（解析网站）、API(用AIP获取数据）</p><p><strong>（2）存储数据：</strong>链接数据库取数、</p><p><strong>（3）展示数据：</strong>可视化高效传达信息</p><p><strong>测量：</strong>设定标准、发现异常、研究关系</p><p>分析数据的目的：及时发现异常，找到数据之间的因果关系（数据是客观统一的）</p><p><strong>（1）设定标准+发现异常</strong></p><h3 id><a href="#" class="headerlink" title></a></h3><p><strong>（2）研究关系：</strong>可视化、建模</p><h4 id="2-实验"><a href="#2-实验" class="headerlink" title="2.实验"></a>2.实验</h4><p>提出假设，然后验证假设</p><p><strong>所有未经事实数据验证的想法都是假设</strong></p><p>如何在业务只有少量数据时设计数据实验？如何在无法同时测试两个版本时比较数据？</p><h4 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h4><p><strong>如何应用数据创造价值？</strong></p><p>基于数据反馈不断迭代产品和业务策略、基于数据训练算法，让机器自动化的完成工作。</p><p><strong>（1）将数据应用于业务</strong></p><p><strong>有明确的业务目标，然后去拆解目标</strong></p><p><strong>数据分析拆解：</strong></p><p>详细内容见下面网址：</p><p><a href="https://blog.csdn.net/weixin_45876414/article/details/124686742">https://blog.csdn.net/weixin_45876414/article/details/124686742</a></p><p>（1）方法</p><p>​<strong>流程拆解法</strong>：流程法就是按照事情发展的时间、流程、顺序，对过程进行逐一的拆解。</p><p>如：进行拆解用户购买商品的流程环节：看到广告–&gt;点进商品–&gt;点击购买–&gt;完成支付–&gt;订单量下降<br>类似于漏斗分析法，是一套流程分析，适用于流程长，环节较多，并且随着环节的进行，留存率越来越少的场景。</p><p>​<strong>二分法</strong>：非常常见的一种方法，就是把事物分成A和非A两个部分，如“白天，黑夜”，“内部、外部”等等</p><p>​<strong>象限拆解法</strong>：通过横纵坐标，将所要分析的内容分成四个象限，由高到低进行分析。</p><p>1.有利于找到问题的共性原因：通过象限分析法，将有相同特征的事件进行归因分析，总结其中的共性原因。</p><p>2.建立分组优化策略：针对投放的象限分析法，可以针对不同象限建立优化策略。</p><p>​<strong>杜邦分析法</strong>：利用几种主要的之间的关系来综合地分析企业的财务状况。</p><p>​公式：ROE&#x3D;净资产利润率<em>权益乘数</em>资产周转率</p><p>（2）模型</p><p>​<strong>AARRR</strong>：AARRR是一个用于研究用户增长的<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B&spm=1001.2101.3001.7020">数据分析模型</a>，是Acquisition、Activation、Retention、Revenue、Refer，这五个单词的缩写，分别对应用户生命周期中的用户获取、用户激活、用户存留、获得收益、推荐传播这五个环节。</p><p>​<strong>PEST</strong>：PEST分析法就是，从政治（Politics）、经济（Economic）、社会（Society）、技术（Technology）四个方面，基于公司战略的眼光来分析企业外部宏观环境的一种方法，公司战略的制定离不开宏观环境，而PEST分析法能从各个方面比较好的把握宏观环境的现状及变化的趋势，有利于企业对生存发展的机会加以利用，对环境可能带来的威胁及早发现避开。</p><p>​<strong>RFM</strong>：RFM是指根据<strong>客户活跃程度和交易金额贡献</strong>，进行客户价值细分的一种方法。对于一个新上线产品的前期运营，我们一般的做法都是做活动、上新品、蹭热点、做营销、不断地去拓展新的客户。但是这种做法收效却不容乐观，真正获取的用户没有几个，最终都便宜了羊毛党。其实客户在不同阶段的需求是不一样的，有的客户图便宜，有的客户看新品，有的客户重服务。所以我们想要运营好一个产品，就需要对客户<strong>精细化运营</strong>。</p><p>​<strong>SWOT</strong>：SWOT分析法代表企业<strong>优势(strength)、劣势(weakness)、机会（opportunity)和威胁(threats)<strong>。因此，SWOT分析实际上是将对企业内部外条件各方面进行综合和概括，进而分析组织的优劣势，面临的机会和威胁的一种方法，可以通过分析帮助企业把资源和行动集中在自己的</strong>强项和有最多机会的</strong>地方。</p><p>​<strong>5W1H</strong>：Who(分析谁) 确定主题、Where(取哪里的数据)进行数据集成、When(取什么时间段的数据)、What(用什么分析方法)、Why (什么原因导致的)、How (如何呈现最终结果)</p><p><strong>（2）将数据应用于算法</strong></p><p>​训练算法：训练一个还不会打怪兽的迪迦奥特曼去打怪兽</p><h3 id="Excel基础操作"><a href="#Excel基础操作" class="headerlink" title="Excel基础操作"></a>Excel基础操作</h3><h4 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h4><h4 id="2-熟悉数据"><a href="#2-熟悉数据" class="headerlink" title="2.熟悉数据"></a>2.熟悉数据</h4><p>ctrl+shift+l：筛选</p><p><img src="/2023/03/10/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/1.1.png" alt="1.1"></p><p>win+上下左右键可以分屏</p><h4 id="3-常用函数"><a href="#3-常用函数" class="headerlink" title="3.常用函数"></a>3.常用函数</h4><p>sumif:sumif(range,critenria,[sum_range])举个例子，比如说求2020-8-21的GMV，首先判断的依旧是日期列，判断的日期是2020-8-21单元格，最后计算的求和列一样的</p><p>若是有很多的需要求解的话，我们直接进行单元格的拖拽即可。一个一个找太费时间了</p>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-KNN算法</title>
      <link href="/2023/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-KNN%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-KNN%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-K近邻算法-KNN-x3D-x3D"><a href="#x3D-x3D-K近邻算法-KNN-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;K近邻算法(KNN)&#x3D;&#x3D;"></a>&#x3D;&#x3D;K近邻算法(KNN)&#x3D;&#x3D;</h3><h4 id="1-什么是KNN算法"><a href="#1-什么是KNN算法" class="headerlink" title="1. 什么是KNN算法"></a>1. 什么是KNN算法</h4><p>KNN算法——寻找未知分类的数据离他最近的n个数据，然后判断它是属于哪一类的</p><h4 id="2-算法实践"><a href="#2-算法实践" class="headerlink" title="2. 算法实践"></a>2. 算法实践</h4><p><strong>通用步骤：</strong></p><p>计算距离（常用欧几里得距离或马氏距离）</p><p>升序排列</p><p>取前k个</p><p>加权平均</p><p><strong>k的选取：</strong></p><p>k太大：导致分类模糊</p><p>k太小：受个例影响，波动较大</p><p><strong>如何选取k：</strong></p><p>经验</p><p>均方根误差</p><h4 id="3-实战应用"><a href="#3-实战应用" class="headerlink" title="3. 实战应用"></a>3. 实战应用</h4><h4 id="（1）癌症监测数据"><a href="#（1）癌症监测数据" class="headerlink" title="（1）癌症监测数据"></a><strong>（1）癌症监测数据</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Prostate_Cancer.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader=csv.DictReader(file)</span><br><span class="line">    datas=[row <span class="keyword">for</span> row <span class="keyword">in</span> reader]</span><br><span class="line"><span class="comment"># print(datas)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#分组(训练集和测试集)</span></span><br><span class="line">random.shuffle(datas)  <span class="comment">#打乱顺序</span></span><br><span class="line">n=<span class="built_in">len</span>(datas)//<span class="number">3</span></span><br><span class="line"></span><br><span class="line">test_set=datas[<span class="number">0</span>:n]</span><br><span class="line">train_set=datas[n:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(test_set)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#KNN</span></span><br><span class="line"><span class="comment">#距离</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">d1,d2</span>):</span><br><span class="line">    res=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> (<span class="string">&quot;radius&quot;</span>,<span class="string">&quot;texture&quot;</span>,<span class="string">&quot;perimeter&quot;</span>,<span class="string">&quot;area&quot;</span>,<span class="string">&quot;smoothness&quot;</span>,<span class="string">&quot;compactness&quot;</span>,<span class="string">&quot;symmetry&quot;</span>,<span class="string">&quot;fractal_dimension&quot;</span>):</span><br><span class="line">        res+=(<span class="built_in">float</span>(d1[key])-<span class="built_in">float</span>(d2[key]))**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res**<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">K=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knn</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment">#1.距离</span></span><br><span class="line">    res=[</span><br><span class="line">        &#123;<span class="string">&quot;result&quot;</span>:train[<span class="string">&#x27;diagnosis_result&#x27;</span>],<span class="string">&quot;distance&quot;</span>:distance(data,train)&#125;</span><br><span class="line">        <span class="keyword">for</span> train <span class="keyword">in</span> train_set</span><br><span class="line">    ]</span><br><span class="line"><span class="comment">#     print(res)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#2.排序--升序</span></span><br><span class="line">    res=<span class="built_in">sorted</span>(res,key=<span class="keyword">lambda</span> item:item[<span class="string">&#x27;distance&#x27;</span>])</span><br><span class="line"><span class="comment">#     print(res)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#3.取前K个</span></span><br><span class="line">    res2=res[<span class="number">0</span>:K]</span><br><span class="line"><span class="comment">#     print(res2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#4.加权平均</span></span><br><span class="line">    result=&#123;<span class="string">&#x27;B&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;M&#x27;</span>:<span class="number">0</span>&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#总距离</span></span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> res2:</span><br><span class="line">        <span class="built_in">sum</span>+=r[<span class="string">&#x27;distance&#x27;</span>]</span><br><span class="line">            </span><br><span class="line"><span class="comment">#     print(result)</span></span><br><span class="line"><span class="comment">#     print(data[&#x27;diagnosis_result&#x27;])</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> res2:</span><br><span class="line">        result[r[<span class="string">&#x27;result&#x27;</span>]]+=<span class="number">1</span>-r[<span class="string">&#x27;distance&#x27;</span>]/<span class="built_in">sum</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> result[<span class="string">&#x27;B&#x27;</span>] &gt; result[<span class="string">&#x27;M&#x27;</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;M&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试阶段</span></span><br><span class="line">correct=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> test <span class="keyword">in</span> test_set:</span><br><span class="line">    result=test[<span class="string">&#x27;diagnosis_result&#x27;</span>]</span><br><span class="line">    result2=knn(test)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> result==result2:</span><br><span class="line">        correct+=<span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># print(correct)</span></span><br><span class="line"><span class="comment"># print(len(test_set))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;准确率：&#123;:.2f&#125;%&quot;</span>.<span class="built_in">format</span>(<span class="number">100</span>*correct/<span class="built_in">len</span>(test_set)))</span><br></pre></td></tr></table></figure><h4 id="（2）KNN实现鸢尾花分类"><a href="#（2）KNN实现鸢尾花分类" class="headerlink" title="（2）KNN实现鸢尾花分类"></a>（2）KNN实现鸢尾花分类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn.datasets <span class="keyword">as</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line">feature = iris[<span class="string">&#x27;data&#x27;</span>]  </span><br><span class="line">target = iris[<span class="string">&#x27;target&#x27;</span>]  </span><br><span class="line"></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(feature, target, test_size=<span class="number">0.2</span>, random_state=<span class="number">2021</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(x_train)  </span></span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">5</span>) </span><br><span class="line"></span><br><span class="line">knn = knn.fit(x_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(knn)  </span><br><span class="line"></span><br><span class="line">y_pred = knn.predict(x_test)</span><br><span class="line">y_true = y_test</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型的分类结果:&#x27;</span>, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;真实的分类结果:&#x27;</span>, y_true)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(knn.score(x_test, y_test))</span><br><span class="line"></span><br><span class="line">test1 = knn.predict([[<span class="number">6.1</span>, <span class="number">3.1</span>, <span class="number">4.7</span>, <span class="number">2.1</span>]])</span><br><span class="line"><span class="built_in">print</span>(test1)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> K近邻算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第五讲</title>
      <link href="/2023/03/05/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%94%E8%AE%B2/"/>
      <url>/2023/03/05/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%94%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-基础知识-x3D-x3D"><a href="#x3D-x3D-基础知识-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基础知识&#x3D;&#x3D;"></a>&#x3D;&#x3D;基础知识&#x3D;&#x3D;</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/2023/03/05/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%94%E8%AE%B2/1.1.jpg" alt="1.1"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 一元函数微分学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第三章</title>
      <link href="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-第三章栈、队列和数组-x3D-x3D"><a href="#x3D-x3D-第三章栈、队列和数组-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第三章栈、队列和数组&#x3D;&#x3D;"></a>&#x3D;&#x3D;第三章栈、队列和数组&#x3D;&#x3D;</h2><h3 id="3-1栈"><a href="#3-1栈" class="headerlink" title="3.1栈"></a>3.1栈</h3><h4 id="3-1-1栈的基本概念"><a href="#3-1-1栈的基本概念" class="headerlink" title="3.1.1栈的基本概念"></a>3.1.1栈的基本概念</h4><p>栈的逻辑结构：与普通线性表相同</p><p>数据的运算：插入、删除操作有区别（栈只能在一端进行插入删除）</p><p><strong>栈的常考题型</strong></p><p>进栈顺序：a-&gt;b-&gt;c-&gt;d-&gt;e，有哪些出栈顺序？</p><p>可用公式代换</p><h4 id="3-1-2栈的顺序存储结构"><a href="#3-1-2栈的顺序存储结构" class="headerlink" title="3.1.2栈的顺序存储结构"></a>3.1.2栈的顺序存储结构</h4><p>GetTop:查：栈的使用场景中大多只访问栈顶元素</p><p>顺序栈缺点是：栈的大小不可变</p><p>我们可以给他分配一个大量的连续的存储空间，但是很可能会造成浪费，so，引入了共享栈的概念</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.1.png" alt="1.1"></p><h4 id="3-1-3栈的链式存储结构"><a href="#3-1-3栈的链式存储结构" class="headerlink" title="3.1.3栈的链式存储结构"></a>3.1.3栈的链式存储结构</h4><p>可以用链式存储方式进行存储</p><h3 id="3-2队列"><a href="#3-2队列" class="headerlink" title="3.2队列"></a>3.2队列</h3><h4 id="3-2-1队列的基本概念"><a href="#3-2-1队列的基本概念" class="headerlink" title="3.2.1队列的基本概念"></a>3.2.1队列的基本概念</h4><p>基本操作和列表相似，也是一种特殊的线性表，只不过是操作受限的。</p><h4 id="3-2-2队列的顺序存储结构"><a href="#3-2-2队列的顺序存储结构" class="headerlink" title="3.2.2队列的顺序存储结构"></a>3.2.2队列的顺序存储结构</h4><p><strong>初始化操作</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.2.png" alt="1.2"></p><p><strong>入队操作</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.3.png" alt="1.3"></p><p><strong>队列已满的条件：rear&#x3D;&#x3D;MaxSize?</strong></p><p>若是前面有元素出队了前面的位置会空出来，队列并没有存满。应该让rear指针重新指回下面的位置。变成<strong>循环队列</strong>。</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.4.png" alt="1.4"></p><p>可以取模运算，即得数会有{0,1,2,…,MaxSize-1}，将存储空间在逻辑上变成了<strong>环状</strong></p><p>队列已满的条件：队尾指针的下一个位置是队头，即(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front</p><p><strong>代价:牺牲一个存储单元</strong></p><p><strong>入队操作：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.5.png" alt="1.5"></p><p><strong>出队操作：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.6.png" alt="1.6"></p><p><strong>方案一：判断队列已满&#x2F;已空</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.7.png" alt="1.7"></p><p>比如说图中左边这个队列，里面元素个数计算方法可为：(2+10-3)%10&#x3D;9</p><p><strong>环形队列会浪费一个存储空间，有的出题老师要求不允许浪费，但是若是在左边存入一个的话，Q.rear&#x3D;Q.front，则队满队空就一样了，没有办法来判断了。</strong></p><p><strong>方案二：size值进行记录从而区分</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.8.png" alt="1.8"></p><p><strong>方案三：用tag值来进行区分</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.9.png" alt="1.9"></p><p><strong>其他出题方式：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.10.png" alt="1.10"></p><p><strong>初始化：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.11.png" alt="1.11"></p><p><strong>判断队列已满：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.12.png" alt="1.12"></p><h4 id="3-2-3队列的链式存储结构"><a href="#3-2-3队列的链式存储结构" class="headerlink" title="3.2.3队列的链式存储结构"></a>3.2.3队列的链式存储结构</h4><p><strong>队列的链式实现</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.13.png" alt="1.13"></p><p><strong>初始化(带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.14.png" alt="1.14"></p><p><strong>初始化(不带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.15.png" alt="1.15"></p><p><strong>入队(带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.16.png" alt="1.16"></p><p><strong>入队(不带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.17.png" alt="1.17"></p><p><strong>出队(带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.18.png" alt="1.18"></p><p><strong>出队(不带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.19.png" alt="1.19"></p><p><strong>队列满的条件</strong></p><p>顺序存储——预分配的空间耗尽时队满</p><p>链式存储——一般不会队满，除非内存不足</p><p>若是计算队列的长度，我们一般情况下是可以从front开始遍历，但是时间复杂度是O(n)，我们可以定义 int length;用来记录队列的长度</p><h4 id="3-2-4双端队列"><a href="#3-2-4双端队列" class="headerlink" title="3.2.4双端队列"></a>3.2.4双端队列</h4><p>栈：只允许从一端插入和删除的线性表</p><p>队列：只允许从一端插入、一段删除的线性表</p><p>双端队列：只允许从两端插入、两端删除的线性表</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.20.png" alt="1.20"></p><p><strong>考点：判断输出序列合法性</strong></p><p>若数据元素输入序列为：1，2，3，4，则哪些输出序列是合法的，哪些是非法的？</p><p>栈中合法的序列，双端序列中也一定合法</p><p><strong>双端队列是队列的一个变种，共享栈也是栈的一个变种。</strong></p><h3 id="3-3栈和队列的应用"><a href="#3-3栈和队列的应用" class="headerlink" title="3.3栈和队列的应用"></a>3.3栈和队列的应用</h3><h4 id="3-3-1栈在括号匹配中的应用"><a href="#3-3-1栈在括号匹配中的应用" class="headerlink" title="3.3.1栈在括号匹配中的应用"></a>3.3.1栈在括号匹配中的应用</h4><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.21.png" alt="1.21"></p><p>从图中可以看出，最后出现的左括号最先被匹配（LIFO）</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.22.png" alt="1.22"></p><p>每出现一个右括号，就会“消耗”一个左括号</p><p>遇到左括号就入栈，遇到右括号，就“<strong>消耗</strong>”一个左括号（即出栈）</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.23.png" alt="1.23"></p><p>一共有三种情况：一种是正好匹配；中间有匹配失败的，即后面都会匹配失败；栈中没有括号了（括号匹配失败）；栈中还剩余括号（括号匹配失败）</p><p><strong>流程图：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.24.png" alt="1.24"></p><p><strong>代码实现：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.25.png" alt="1.25"></p><p>考试中可以直接使用基本操作，建议简要说明接口（即用注释的方式简单说明一下）</p><p><strong>因为是用静态数组存放，如果存满了怎么办？</strong></p><p>实际中可以用链栈，但是考试中用顺序栈相对来说更简单一点。</p><h4 id="3-3-2栈在表达式求值中的应用"><a href="#3-3-2栈在表达式求值中的应用" class="headerlink" title="3.3.2栈在表达式求值中的应用"></a>3.3.2栈在表达式求值中的应用</h4><p><strong>算术表达式</strong>：操作数、运算符、界限符（就像小括号那种，是必不可少的，反映了计算的先后顺序）</p><p>中缀表达式：运算符在两个操作数中间</p><p>后缀表达式：运算符在两个操作数后面</p><p>前缀表达式：运算符在两个操作数前面</p><p>中缀：a+b-c  —-   a+b-c*d</p><p>后缀：ab+c-、abc-+  —-   ab+cd*-</p><p>前缀：-+abc、+-abc  —-   -+ab*cd</p><p><strong>中缀转后缀：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.26.png" alt="1.26"></p><p>不同的运算顺序会导致不同的结果，<strong>左优先</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.27.png" alt="1.27"></p><p>客观来讲做有两种都正确，只是“机算”的结果是前者，<strong>考试中用左边的来运算才是正确的</strong>。<strong>考试中遵循左优先原则：只要左边的运算符能先计算，就优先算左边的</strong>（可保证运算顺序唯一）</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.28.png" alt="1.28"></p><p><strong>后缀表达式的计算（机算）</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.29.png" alt="1.29"></p><p>后缀表达式适用于基于栈的编程语言，如：Forth、PostScripts</p><p><strong>一个中缀表达式只对应一个后缀表达式（确保算法的“确定性”）</strong></p><p><strong>中缀转前缀：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.30.png" alt="1.30"></p><p><strong>前缀表达式的计算：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.31.png" alt="1.31"></p><p><strong>代码实现：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.32.png" alt="1.32"></p><p><strong>中缀表达式的计算（用栈实现）:</strong></p><p>后缀表达式的计算：栈是用来存放当前暂时还不能确定运算次序的操作数</p><p>中缀表达式转后缀：栈是用来存放当前暂时还不能确定运算次序的运算符</p><p><strong>中缀转后缀+后缀表达式求值&#x3D;两个算法的结合</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.33.png" alt="1.33"></p><h4 id="3-3-3栈在递归中的应用"><a href="#3-3-3栈在递归中的应用" class="headerlink" title="3.3.3栈在递归中的应用"></a>3.3.3栈在递归中的应用</h4><p>递归——函数调用的过程</p><p>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</p><p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但<strong>规模较小</strong>的问题</p><p>递归中重要的两个比较重要的东西：递归表达式（递归体）、边界条件（递归出口）</p><p><strong>递归算法的缺点</strong>：太多层递归可能会导致栈溢出、可能包含很多重复计算</p><h4 id="3-3-4栈在层次遍历中的应用"><a href="#3-3-4栈在层次遍历中的应用" class="headerlink" title="3.3.4栈在层次遍历中的应用"></a>3.3.4栈在层次遍历中的应用</h4><p>树的层次遍历、图的广度优先遍历</p><h4 id="3-3-5队列在计算机系统中的应用"><a href="#3-3-5队列在计算机系统中的应用" class="headerlink" title="3.3.5队列在计算机系统中的应用"></a>3.3.5队列在计算机系统中的应用</h4><p>在操作系统中的应用——多个进程争抢着使用有限的系统资源时，<strong>FCFS</strong>（<strong>先来先服务</strong>）是一种常用策略。（可用队列实现）</p><h3 id="3-4数组和特殊矩阵"><a href="#3-4数组和特殊矩阵" class="headerlink" title="3.4数组和特殊矩阵"></a>3.4数组和特殊矩阵</h3><h4 id="3-4-1数组的定义"><a href="#3-4-1数组的定义" class="headerlink" title="3.4.1数组的定义"></a>3.4.1数组的定义</h4><p>详情见课本</p><h4 id="3-4-2数组的存储结构"><a href="#3-4-2数组的存储结构" class="headerlink" title="3.4.2数组的存储结构"></a>3.4.2数组的存储结构</h4><p><strong>一维数组的存储结构</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.34.png" alt="1.34"></p><p><strong>二维数组的存储结构</strong>：行优先、列优先</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.35.png" alt="1.35"></p><p>列存储的话就是（j*M+j）</p><h4 id="3-4-3特殊矩阵的压缩存储"><a href="#3-4-3特殊矩阵的压缩存储" class="headerlink" title="3.4.3特殊矩阵的压缩存储"></a>3.4.3特殊矩阵的压缩存储</h4><p><strong>普通矩阵的存储</strong></p><p><strong>（1）对称矩阵的压缩存储</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.36.png" alt="1.36"></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.37.png" alt="1.37"></p><p><strong>有的数组下标是从1开始的，所以就不需要再-1了，要注意数组下标</strong></p><p>记住对称矩阵的性质：</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.38.png" alt="1.38"></p><p><strong>（2）三角矩阵的压缩存储</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.39.png" alt="1.39"></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.40.png" alt="1.40"></p><p><strong>三对角矩阵的压缩存储</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.41.png" alt="1.41"></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.42.png" alt="1.42"></p><h4 id="3-4-4稀疏矩阵"><a href="#3-4-4稀疏矩阵" class="headerlink" title="3.4.4稀疏矩阵"></a>3.4.4稀疏矩阵</h4><p>压缩存储的方法：三元组法（失去随机存储的特性）、<strong>十字链表法</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.43.png" alt="1.43"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈、队列和数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第四讲</title>
      <link href="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%9B%9B%E8%AE%B2/"/>
      <url>/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%9B%9B%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-基础知识-x3D-x3D"><a href="#x3D-x3D-基础知识-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基础知识&#x3D;&#x3D;"></a>&#x3D;&#x3D;基础知识&#x3D;&#x3D;</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%9B%9B%E8%AE%B2/1.1.jpg" alt="1.1"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%9B%9B%E8%AE%B2/1.2.jpg" alt="1.2"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 一元函数微分学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第三讲</title>
      <link href="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%89%E8%AE%B2/"/>
      <url>/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-基础知识-x3D-x3D"><a href="#x3D-x3D-基础知识-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基础知识&#x3D;&#x3D;"></a>&#x3D;&#x3D;基础知识&#x3D;&#x3D;</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%89%E8%AE%B2/1.1.jpg" alt="1.1"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%89%E8%AE%B2/1.2.jpg" alt="1.2"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 函数极限与连续 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数重要公式</title>
      <link href="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="高数重要公式"><a href="#高数重要公式" class="headerlink" title="高数重要公式"></a>高数重要公式</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/1.1.jpg" alt="1.1"></p><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/1.2.jpg" alt="1.2"></p><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/1.3.jpg" alt="1.3"></p><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/1.4.jpg" alt="1.4"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 重要公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构算法</title>
      <link href="/2023/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="第二章线性表"><a href="#第二章线性表" class="headerlink" title="第二章线性表"></a>第二章线性表</h3><h4 id="2-2-3试题精选"><a href="#2-2-3试题精选" class="headerlink" title="2.2.3试题精选"></a>2.2.3试题精选</h4><h5 id="01"><a href="#01" class="headerlink" title="01"></a>01</h5><p>算法思想：搜索整个顺序表，找到最小值记住其位置，搜索结束后直接令最后第一元素填补该位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Del_Min</span><span class="params">(SqList &amp;L,ElemType &amp;value)</span>&#123;</span><br><span class="line">  <span class="comment">//删除顺序表L中最小值元素节点，并通过引用型参数value返回其值</span></span><br><span class="line">  <span class="comment">//若删除失败返回false</span></span><br><span class="line">  <span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  value=L.data[<span class="number">0</span>];<span class="comment">//value等于0号元素</span></span><br><span class="line">  <span class="type">int</span> pos=<span class="number">0</span>;<span class="comment">//假设0号元素最小</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;L.length;i++）</span><br><span class="line">      <span class="keyword">if</span>(L.data[i]&lt;value)&#123;</span><br><span class="line">        value=L.data[i];<span class="comment">//把最小值赋值给value</span></span><br><span class="line">        pos=i;<span class="comment">//记住最小值的位置</span></span><br><span class="line">      &#125;</span><br><span class="line">  L.data[pos]=L.data[L.length<span class="number">-1</span>];   <span class="comment">//把最后一个元素填补到最小值的位置</span></span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//此时，value的值为最小值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细解法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delMin</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!len) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组为空&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min = *arr, minPos = <span class="number">0</span>;<span class="comment">//min是第一个元素，minPos是第一个元素的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; *(arr + i))&#123;</span><br><span class="line">min = *(arr + i);</span><br><span class="line">minPos = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到最小值之后，我们需要进行的操作是：将最后一个元素给他挪到之前最小值元素那里去</span></span><br><span class="line">*(arr + minPos) = *(arr + len - <span class="number">1</span>);  <span class="comment">//挪一下</span></span><br><span class="line">*(arr + len - <span class="number">1</span>) = <span class="literal">NULL</span>;<span class="comment">//挪完之后，要将这个位置上的元素设为NULL，因为现在数组的长度为length-1了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//手动输入数组的元素个数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数组长度：n=&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(n));<span class="comment">//动态分配数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数组的元素值：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">delMin(arr, n);<span class="comment">//调用delMin函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解：本题中主要是通过循环搜索整个顺序表，<strong>之后通过令最后一个元素填补，达到L.length–的目的</strong>。像这种类型算法，一般假设第一个元素是最小值，之后循环中比较即可。</p><h5 id="02"><a href="#02" class="headerlink" title="02"></a>02</h5><p>算法思想：逆置就是使元素按原顺序的相反顺序排序，我们可以将顺序表的前半部分与后半部分交换位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Recersr</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">ElemType temp;<span class="comment">//辅助变量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">temp=L.data[i];<span class="comment">//交换L.data[i]与L.data[L.legth-i-1]的位置</span></span><br><span class="line">L.data[i]=L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">L.data[L.length-i<span class="number">-1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细解法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法思想：逆置就是将前半部分与后半部分元素对换位置，根据数学关系联系起来即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseS</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;<span class="comment">//只需要i&lt;len/2就可以了</span></span><br><span class="line">tmp = arr[i];<span class="comment">//中间元素</span></span><br><span class="line">arr[i] = arr[len-i<span class="number">-1</span>];<span class="comment">//关于中间元素对称的元素交换位置，实现逆置</span></span><br><span class="line">arr[len-i<span class="number">-1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//手动输入数组的元素个数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数组长度：n=&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(n));<span class="comment">//动态分配数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数组的元素值：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">reverseS(arr, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理解：题目要求将顺序表中所有元素逆置，这种情况下我们可以前半部分和后半部分进行交换，达到逆置的效果。</p><h5 id="03"><a href="#03" class="headerlink" title="03"></a>03</h5><p>算法思想：k（k&#x3D;0）记录顺序表中不等于x的元素个数，在扫描过程中，将不等于x的元素移动到下标为k的位置，更新k的值，扫描结束后，修改L的长度。</p><p>解法一：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del_x_1</span><span class="params">(SqList &amp;L,ElemType x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>,i;<span class="comment">//记录不等于x的元素个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i]!=x)&#123;</span><br><span class="line">L.data[k]=L.data[i];<span class="comment">//将不等于x的元素移动到k的位置</span></span><br><span class="line">k++;<span class="comment">//更新k的值</span></span><br><span class="line">&#125;</span><br><span class="line">L.length=k;<span class="comment">//修改L的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于是扫描元素之后将不等于x的元素在L上覆盖了一遍，其中L中不等于x的数据元素的顺序没有改变。可以看做两个顺序表。</p><p>解法二：</p><p>算法思想：这种思想可以看做在本身表上直接移动，这个就是一个顺序表上进行操作。相当于遇到等于x的元素直接前移覆盖x，这样的话后面会空出来，直接L.length-k就可得到L的长度。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del_x_2</span><span class="params">(SqList &amp;L,ElemType x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;<span class="comment">//k值记录L中等于x的元素个数</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;L.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==x)</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L.data[i-k]=L.data[i];<span class="comment">//当前元素前移k个位置</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">L.length=L.length-k;<span class="comment">//顺序表的长度递减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="04"><a href="#04" class="headerlink" title="04"></a>04</h5><p>算法思想：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Del_s_t2</span><span class="params">(SqList &amp;L,ElemType s.ElemType t)</span>&#123;</span><br><span class="line"><span class="comment">//删除有序表L中值在给定值s与t之间的所有元素</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=t || L.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length &amp;&amp; L.data[i]&lt;s;i++)</span><br><span class="line"><span class="keyword">if</span>(i&gt;=L.length)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;L.length &amp;&amp; L.data[j]&lt;=t;j++)</span><br><span class="line"><span class="keyword">for</span>(;j&lt;L.length;i++;j++)</span><br><span class="line">L.data[i]=L.data[j];</span><br><span class="line">L.length=i;</span><br><span class="line"><span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数据结构算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第二章</title>
      <link href="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-第二章线性表-x3D-x3D"><a href="#x3D-x3D-第二章线性表-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第二章线性表&#x3D;&#x3D;"></a>&#x3D;&#x3D;第二章线性表&#x3D;&#x3D;</h2><h3 id="2-1线性表的定义和基本操作"><a href="#2-1线性表的定义和基本操作" class="headerlink" title="2.1线性表的定义和基本操作"></a>2.1线性表的定义和基本操作</h3><h4 id="2-1-1线性表的定义"><a href="#2-1-1线性表的定义" class="headerlink" title="2.1.1线性表的定义"></a>2.1.1线性表的定义</h4><p><strong>相同</strong>(每个数据元素所占空间一样大)数据类型</p><p>有限序列(有次序)</p><p>第i个——位序</p><h4 id="2-1-2-线性表的基本操作"><a href="#2-1-2-线性表的基本操作" class="headerlink" title="2.1.2 线性表的基本操作"></a>2.1.2 线性表的基本操作</h4><p>Tips：</p><p>1.对数据的操作（记忆思路）——创销、增删改查</p><p>2.C语言函数的定义——&lt;返回值类型&gt;函数名(&lt;参数1类型&gt;参数1, &lt;参数2类型&gt;参数2…)</p><p>3.实际开发中，可根据实际需求定义其他的基本操作</p><p>4.函数名和参数的形式、命名都可以改变，but要有可读性</p><p><strong>5</strong>.什么时候要传入引用“&amp;”——对参数的修改结果需要“<strong>带回来</strong>”</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">x = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test函数内部 x=%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;调用test前 x=%d\n&quot;</span>, x);</span><br><span class="line">test(x);<span class="comment">//里面的x只是main的复制品</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;调用test后 x=%d\n&quot;</span>, x);<span class="comment">//对参数的修改没带回来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​结果：<img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.1.png" alt="1.1"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> &amp; x)</span> &#123;</span><br><span class="line">x = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test函数内部 x=%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;调用test前 x=%d\n&quot;</span>, x);</span><br><span class="line">test(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;调用test后 x=%d\n&quot;</span>, x);<span class="comment">//对参数的修改带回来了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​结果：<img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.2.png" alt="1.2"></p><h3 id="2-2线性表的顺序表示"><a href="#2-2线性表的顺序表示" class="headerlink" title="2.2线性表的顺序表示"></a>2.2线性表的顺序表示</h3><h4 id="2-2-1顺序表的定义"><a href="#2-2-1顺序表的定义" class="headerlink" title="2.2.1顺序表的定义"></a>2.2.1顺序表的定义</h4><p>如何知道一个数据元素的大小？</p><p>C语言   sizeof(ElemType)，ElemType就是你的顺序表中存放的数据元素类型</p><p>顺序表所占的存储空间&#x3D;表长✖sizeof(元素的类型)</p><p><strong>静态分配：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data[MaxSize];<span class="comment">// 用静态的“数组”存放数据元素</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">// 顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">// 顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作——初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;MaxSize; i++)</span><br><span class="line">    L.data[i] = <span class="number">0</span>;<span class="comment">// 将所有数据元素设置为默认初始值</span></span><br><span class="line">  L.length = <span class="number">0</span>;<span class="comment">// 顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">SqList L;<span class="comment">// 声明一个顺序表</span></span><br><span class="line">  InitList(L);<span class="comment">// 初始化顺序表</span></span><br><span class="line">  <span class="comment">//......未完待续，后续操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>静态数组的长度是不可变的，声明之后，数组的大小和空间事先已经固定，所以有一定的局限性</strong></p><p><strong>动态分配：</strong></p><p>Key：动态申请和释放内存空间</p><p>C —-     malloc、 free  函数</p><p>malloc：会申请一整片连续的内存空间</p><p>malloc 函数返回一个指针，需要强制转型为你定义的数据元素类型指针。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//malloc、free 函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> *data;<span class="comment">// 指示动态分配数组的指针</span></span><br><span class="line">  <span class="type">int</span> MaxSize;<span class="comment">// 顺序表的最大容量</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">// 顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">// 顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作——初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">  <span class="comment">// 用 malloc 函数申请一片连续的存储空间</span></span><br><span class="line">  L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  L.length = <span class="number">0</span>;<span class="comment">// 顺序表初始长度为0</span></span><br><span class="line">  L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">  <span class="type">int</span> *p = L.data;</span><br><span class="line">  L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize)+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;L.length; i++)&#123;</span><br><span class="line">    L.data[i]=p[i];     <span class="comment">// 将数据复制到新区域（but 时间开销大）</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.MaxSize = L.MaxSize+len;<span class="comment">// 顺序表最大长度增加 len</span></span><br><span class="line">  <span class="built_in">free</span>(p);<span class="comment">// 释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">SqList L;<span class="comment">// 声明一个顺序表</span></span><br><span class="line">  InitList(L);<span class="comment">// 初始化顺序表</span></span><br><span class="line">  <span class="comment">//......往顺序表中随便插入几个元素</span></span><br><span class="line">  IncreaseSize(L,<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.3.png" alt="1.3"></p><p>绿色那块会被释放，因为 free 函数</p><p><strong>顺序表的特点：</strong></p><p>（1）随机访问：能在O(1)的时间内找到第i个元素</p><p>（2）存储密度高</p><p>（3）拓展容量不方便</p><p>（4）插入、删除操作不方便，需要移动大量元素</p><h4 id="2-2-2顺序表上基本操作的实现"><a href="#2-2-2顺序表上基本操作的实现" class="headerlink" title="2.2.2顺序表上基本操作的实现"></a>2.2.2顺序表上基本操作的实现</h4><p><strong>顺序表的基本操作——插入</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.4.png" alt="1.4"></p><p>其中i的合法值 [1,length+1]</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.5.png" alt="1.5"></p><p><strong>插入操作的时间复杂度</strong>——关注最深层循环语句的执行次数与问题规模n的关系</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.6.png" alt="1.6"></p><p>问题规模——   n&#x3D;L.length</p><p>最好情况——新元素插入表尾，不需要移动元素，i&#x3D;n+1,循环0次，                          最好时间复杂度 &#x3D; O(1)</p><p>最坏情况——新元素插入表头，需要将原有的n个元素全都向后移动，i&#x3D;1,循环n次，最好时间复杂度 &#x3D; O(1)</p><p>平均时间复杂度——p&#x3D;1&#x2F;(n+1)</p><p><strong>顺序表的基本操作——删除</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.7.png" alt="1.7"></p><p>e是引用变量，所以在bool和main中，都是同一个</p><p><strong>时间复杂度</strong>——见课本</p><p><strong>顺序表的按位查找</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 <span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> struce&#123;</span><br><span class="line">  <span class="type">int</span> *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">  <span class="type">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span>&#123;</span><br><span class="line">  <span class="comment">//用malloc 函数申请一片连续的存储空间</span></span><br><span class="line">  L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//注意是(int *)</span></span><br><span class="line">  L.length=<span class="number">0</span>;</span><br><span class="line">  L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然指针指向的都是同一个地址，但是若是指针对应的数据类型对应错的话，访问数据元素的时候也会出现问题</p><p><strong>顺序表的按值查找</strong></p><p><strong>注意</strong>：基本数据类型：int、char、double、float 等可以直接用运算符“&#x3D;&#x3D;”比较，但是结构类型的数据元素不可比较</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.23.png" alt="1.23"></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>(1)<strong>顺序存储结构和链式存储结构的区别：</strong></p><p>链表存储结构的内存地址不一定是连续的，但顺序存储结构的内存地址一定是连续的；</p><p>链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查询时使用。</p><p>只有顺序表可以按序号随机存储，且在最后进行插入和删除操作时不需要移动任何元素</p><p>(2)<strong>顺序存储结构和链式存储结构的优缺点：</strong></p><p><strong>顺序存储：</strong>优点：可随机存取，存储密度高</p><p>​缺点：要求大片连续空间，改变容量不方便</p><p><strong>链式存储</strong>：优点：不要求大片连续空间，改变容量方便</p><p>​ 缺点：不可随机存储，要耗费一定空间存放指针</p><p>  空间上：</p><p>​顺序比链式节约空间。是因为链式结构每一个节点都有一个指针存储域。</p><p>存储操作上：</p><p>​顺序支持<strong>随机存取</strong>，方便操作</p><p>插入和删除上：</p><p>​链式的要比顺序的方便（因为插入的话顺序表也很方便，问题是顺序表的插入要执行更大的空间复杂度，包括一个从表头索引以及索引后的元素后移，而链表是索引后，插入就完成了）</p><p>​例如：当你在字典中查询一个字母j的时候，你可以选择两种方式，第一，顺序查询，从第一页依次查找直到查询到j。第二，索引查询，从字典的索引中，直接查出j的页数，直接找页数，或许是比顺序查询最快的。  </p><h3 id="2-3线性表的链式表示"><a href="#2-3线性表的链式表示" class="headerlink" title="2.3线性表的链式表示"></a>2.3线性表的链式表示</h3><h4 id="2-3-1单链表的定义"><a href="#2-3-1单链表的定义" class="headerlink" title="2.3.1单链表的定义"></a>2.3.1单链表的定义</h4><p>LNode:强调返回的是一个节点</p><p>LinkList:强调这是一个单链表</p><p>但是本质上两者表达的都是同一个意思</p><p><strong>不带头结点的单链表</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.8.png" alt="1.8"></p><p><strong>带头结点</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.9.png" alt="1.9"></p><p><strong>带头结点，写代码更方便一点</strong></p><h4 id="2-3-2单链表上的基本操作"><a href="#2-3-2单链表上的基本操作" class="headerlink" title="2.3.2单链表上的基本操作"></a>2.3.2单链表上的基本操作</h4><p><strong>按位序插入（带头结点）</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.10.png" alt="1.10"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.11.png" alt="1.11"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.12.png" alt="1.12"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.13.png" alt="1.13"></p><p><strong>按位序插入（不带头结点）</strong></p><p>这种情况除了i&#x3D;1位置的元素需要特殊处理之外，其余算法原理相同</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.14.png" alt="1.14"></p><p>推荐使用带头结点的方式</p><p><strong>指定节点的后插操作</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.15.png" alt="1.15"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.16.png" alt="1.16"></p><p><strong>指定节点的前插操作</strong></p><p>&#x2F;&#x2F;前插操作：在p节点之前插入元素e</p><p>第一种方法——传入头指针，循环查找p的前驱q，再对q后插，这种的时间复杂度是O(n)</p><p>第二种方法——可以直接在p节点后面插入一个新节点，之后通过赋值实现前插操作，这里时间复杂度是O(1)，此方法偷天换日，绝妙！</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.17.png" alt="1.17"></p><p><strong>按位序删除（带头结点）</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.18.png" alt="1.18"></p><p>最坏、平均时间复杂度：O(n)</p><p>最好时间复杂度：O(1)</p><p><strong>指定节点的删除</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.19.png" alt="1.19"></p><p>极限情况——若p节点正好是最后一个节点，p-&gt;next这行代码会报错</p><p><strong>由此可知，单链表的局限性：无法逆向检索，有时候太不方便了</strong></p><p><strong>按位查找</strong></p><p>极端情况：</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.20.png" alt="1.20"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.21.png" alt="1.21"></p><p>平均时间复杂度：O(n)</p><p><strong>按值查找</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.22.png" alt="1.22"></p><p>时间复杂度：O(n)</p><p>如果ElemType是更复杂的结构类型呢？</p><p>小节中有解决方法</p><p>求表的长度：</p><p>时间复杂度：O(n)</p><p><strong>尾插法建立单链表</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.24.png" alt="1.24"></p><p>but 每次都从头开始遍历，时间复杂度为O(n²) (0+1+2+…+(n-1)&#x3D;所以时间复杂度为O(n²))</p><p>&#x2F;&#x2F;后插操作</p><p>课本P29页有详细代码</p><p><strong>头插法建立单链表</strong></p><p>课本P28页见代码</p><p>养成好习惯，只要是初始化单链表，都先把头指针指向NULL</p><p>头插法：单链表的逆置</p><p><strong>知识回顾与重要知识点</strong></p><p>头插法、尾插法：核心就是初始化操作、指定节点的后插操作</p><p>(注意设置一个指向表尾节点的指针)</p><p><strong>头插法的重要应用：链表的逆置</strong></p><h4 id="2-3-3双链表"><a href="#2-3-3双链表" class="headerlink" title="2.3.3双链表"></a>2.3.3双链表</h4><p><strong>双链表的初始化</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.25.png" alt="1.25"></p><p><strong>双链表的插入</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.26.png" alt="1.26"></p><p><strong>双链表的删除</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.27.png" alt="1.27"></p><p><strong>双链表的遍历</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.28.png" alt="1.28"></p><h4 id="2-3-4循环链表"><a href="#2-3-4循环链表" class="headerlink" title="2.3.4循环链表"></a>2.3.4循环链表</h4><p><strong>循环单链表</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.29.png" alt="1.29"></p><p>单链表：从一个节点出发只能找到后续的各个节点</p><p>循环单链表：从一个节点出发可以找到其他任何一个节点</p><p><strong>循环双链表的初始化</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.30.png" alt="1.30"></p><p><strong>双链表的插入</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.31.png" alt="1.31"></p><p><strong>双链表的删除</strong></p><p>课本p33页见代码</p><h4 id="2-3-5静态链表"><a href="#2-3-5静态链表" class="headerlink" title="2.3.5静态链表"></a>2.3.5静态链表</h4><p><strong>用代码定义一个静态链表</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.32.png" alt="1.32"></p><p>还有一种方法见课本</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.33.png" alt="1.33"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.34.png" alt="1.34"></p><p>SLinkList b —— 相当于定义了一个长度为MaxSize的Node型数组</p><p>静态链表：用数组的方式实现的链表</p><p>优点：增、删 操作不需要大量移动元素</p><p>缺点：不能随机存取，只能从头节点开始依次往后查找；<strong>容量固定不可变</strong>。</p><p>适用场景：不支持指针的低级语言；数据元素数量固定不变的场景(如操作系统的文件分配表FAT)</p><h4 id="2-3-6顺序表和链表的比较"><a href="#2-3-6顺序表和链表的比较" class="headerlink" title="2.3.6顺序表和链表的比较"></a>2.3.6顺序表和链表的比较</h4><p><strong>1.逻辑结构</strong></p><p>都属于线性表，都是线性结构</p><p><strong>2.物理结构&#x2F;存储结构</strong></p><p>顺序表：</p><p>优点：支持随机存储、存储密度高</p><p>缺点：大片连续空间分配不方便，改变容量不方便</p><p>链表：</p><p>优点：离散的小空间分配方便，改变容量方便</p><p>缺点：不可随机存取，存储密度低</p><p><strong>3.数据的运算&#x2F;基本操作</strong></p><p>创销、增删改查</p><p>顺序表（创）：</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.35.png" alt="1.35"></p><p>链表（创）：</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.36.png" alt="1.36"></p><p>顺序表（销）：</p><p>静态分配，系统会直接回收；若是动态分配，需要手动free(malloc和free必须成对出现)</p><p>链表（销）：</p><p>依次删除各个节点（free）</p><p>顺序表（增、删）：</p><p>插入&#x2F;删除元素都要将后续元素后移&#x2F;前移。时间复杂度：O(n)，时间开销主要来自移动元素。</p><p><strong>注意：</strong>若数据元素很大，则移动的时间代价很高</p><p>链表（增、删）：</p><p>插入&#x2F;删除元素只需修改指针即可。时间复杂度：O(n)，时间开销主要来自查找目标元素。</p><p><strong>注意：</strong>查找元素的时间代价更低</p><p>顺序表（查）：</p><p>按位查找：具体时间复杂度见课本P34</p><p>链表（查）：</p><p>见课表O(n)</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.37.png" alt="1.37"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数课后题1.2</title>
      <link href="/2023/02/03/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.2/"/>
      <url>/2023/02/03/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.2/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;高数课后题1.2&#x3D;&#x3D;</p><p><img src="/2023/02/03/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.2/1.1.jpg" alt="1.1"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 数列极限 </tag>
            
            <tag> 高数课后练习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第一章</title>
      <link href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-2-算法和算法评价"><a href="#1-2-算法和算法评价" class="headerlink" title="1.2 算法和算法评价"></a>1.2 算法和算法评价</h3><h5 id="1-2-1-算法的基本概念"><a href="#1-2-1-算法的基本概念" class="headerlink" title="1.2.1 算法的基本概念"></a>1.2.1 算法的基本概念</h5><p>注：算法必须是有穷的，而程序可以是无穷的</p><p><strong>高效率</strong>：花的时间少，时间复杂度低</p><p><strong>低存储量需求</strong>：不费内存，空间复杂度低</p><p><strong>评估算法时间开销</strong>：（可以用事后统计但是存在问题）：</p><p>（1）机器性能，如：超级计算机vs单片机</p><p>（2）编译语言：语言越高级，执行效率越低</p><p>（3）与编译程序产生的机器指令质量有关</p><p>（4）某些算法不可事后统计，如：导弹控制算法</p><h5 id="1-2-2-算法的时间复杂度"><a href="#1-2-2-算法的时间复杂度" class="headerlink" title="1.2.2 算法的时间复杂度"></a>1.2.2 算法的时间复杂度</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//算法一 —— 逐步递增型爱你</span></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">loveYou(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span> &#123;  <span class="comment">//n 为问题规模</span></span><br><span class="line">（<span class="number">1</span>）<span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//爱你的程度</span></span><br><span class="line">（<span class="number">2</span>） <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">（<span class="number">3</span>）i++;  <span class="comment">//每次+1</span></span><br><span class="line">（<span class="number">4</span>）  <span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">（<span class="number">5</span>）    <span class="built_in">printf</span>(<span class="string">&quot;I Love You More Than %d\n&quot;</span>,n);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句<strong>频度</strong>：</p><p>（1）——1次</p><p>（2）——3001次                                                                                                                                                                                                                                                                                         </p><p>（3）（4）——3000次</p><p>（5）——1次</p><p>T(3000)&#x3D;1+3001+2*3000+1</p><p>时间开销与问题规模n的关系:T(n)&#x3D;3n+3</p><p><strong>问题一：</strong>是否可以忽略表达式中的某些部分？</p><p><img src="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1.png" alt="1.1"></p><p><strong>我们可以直接把低阶的部分去掉和系数变为1，保留阶数更高的部分就行</strong></p><p>T1(n)&#x3D;O(n)，其中O表示“同阶”，同等数量级。</p><p><strong>常见的渐进时间复杂：</strong>（常对幂指阶）</p><p><img src="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2.png" alt="1.2"></p><p><strong>问题二：如果有好几千行代码，按这种方法需要一行一行数？</strong></p><p>​结论一：顺序执行的代码只会影响常数项，可以忽略</p><p>​结论二：只需挑循环中的<strong>一个基本操作</strong>分析它的执行次数与n的关系即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;<span class="comment">//外层循环执行n次</span></span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//嵌套两层循环</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am Iron Man\n&quot;</span>);<span class="comment">//内层循环共执行n²次</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You More Than %d\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​时间开销与问题规模的n的关系：</p><p>​T(n)&#x3D;O(n)+O(n²)&#x3D;O(n²)&#x2F;&#x2F;加法规则</p><p>​结论三：如果有多层嵌套循环，只需关注最深层循环循环了几次</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法3—— 指数递增型爱你</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//n 为问题规模</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;<span class="comment">//爱你的程度</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">i = i * <span class="number">2</span>;<span class="comment">//每次翻倍</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You More Than %d\n&quot;</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3.png" alt="1.3"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法4—— 搜索数字型爱你</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> flag[], <span class="type">int</span> n)</span> &#123;<span class="comment">//n 为问题规模</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Am Iron Man\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//从第一个元素开始查找</span></span><br><span class="line"><span class="keyword">if</span> (flag[i] == n) &#123;<span class="comment">//找到元素n</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>, n);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//找到后跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//flag 数组中乱序存放了 1~n 这些数</span></span><br><span class="line"><span class="type">int</span> flag[n] = &#123; <span class="number">1.</span>...n &#125;;</span><br><span class="line">loveYou(flag, n);</span><br></pre></td></tr></table></figure><p>​计算上述算法的时间复杂度T(n):</p><p>​    最好情况：元素n在第一个位置–最好时间复杂度T(n)&#x3D;O(1)</p><p>​最坏情况：元素n在最后一个位置    –最坏时间复杂度T(n)&#x3D;O(n)</p><p>​平均情况：假设元素n在任意一个位置的概率相同为1&#x2F;n          –平均时间复杂度          T(n)&#x3D;O(n)</p><p><img src="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4.png" alt="1.4"></p><p><strong>很多算法执行时间与输入的数据有关</strong></p><h5 id="1-2-3-空间复杂度"><a href="#1-2-3-空间复杂度" class="headerlink" title="1.2.3 空间复杂度"></a>1.2.3 空间复杂度</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span> &#123;  <span class="comment">//n 为问题规模</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//爱你的程度</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">i++;  <span class="comment">//每次+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You More Than %d\n&quot;</span>, n);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法中，不管n的值如何变化，它所需要的内存空间大小都是固定不变的一个常数值，算法<strong>空间复杂度</strong>为：    S(n) &#x3D; O(1)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  <span class="type">int</span> flagp[n];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">//......此处省略很多代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一个int变量占 4B….. 则所需内存空间 &#x3D; 4+4n+4 &#x3D; 4n+8</p><p>则 S(n)&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  <span class="type">int</span> flag[n][n];<span class="comment">//声明 n*n 维的二维数组</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">//......此处省略很多代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所需内存空间 &#x3D; 4n²+4          则 S(n)&#x3D;O(n²)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  <span class="type">int</span> flag[n][n];<span class="comment">//声明 n*n 维的二维数组</span></span><br><span class="line">  <span class="type">int</span> other[n];<span class="comment">//声明一个长度为n的数组</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">//......此处省略很多代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>S(n) &#x3D; O(n²)+O(n)+O(1)&#x3D;O(n²)       &#x2F;&#x2F;加法规则</p><p><strong>函数递归调用带来的内存开销</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法5—— 递归型爱你</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="comment">//n 为局部变量</span></span><br><span class="line">  <span class="type">int</span> a, b, c;<span class="comment">//声明一系列局部变量</span></span><br><span class="line">  <span class="comment">//...... 省略代码</span></span><br><span class="line">  <span class="keyword">if</span> (n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    loveYou(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  loveYou(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设每层调用k个字节，则n层就是kn个字节</p><p>S(n)&#x3D;O(n)<strong>空间复杂度&#x3D;递归调用的深度</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法5—— 递归型爱你</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="comment">//n 为局部变量</span></span><br><span class="line">  <span class="type">int</span> flag[n];<span class="comment">//声明一个数组</span></span><br><span class="line">  <span class="type">int</span> a, b, c;<span class="comment">//声明一系列局部变量</span></span><br><span class="line">  <span class="comment">//...... 省略代码</span></span><br><span class="line">  <span class="keyword">if</span> (n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    loveYou(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  loveYou(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各级递归调用所需要的存储flag数组的空间为：1+2+3+….+n&#x3D;[n(1+n)&#x2F;2]&#x3D;(1&#x2F;2)n²+(1&#x2F;2)n</p><p>S(n)&#x3D;O(n²)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数据结构第一章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数课后题1.1</title>
      <link href="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/"/>
      <url>/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;高数课后题1.1&#x3D;&#x3D;</p><p>课本是同济大学数学系编，只做了一些重点题。</p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.1.jpg" alt="1.1"></p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.2.jpg" alt="1.2"></p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.3.jpg" alt="1.3"></p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.4.jpg" alt="1.4"></p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.5.jpg" alt="1.5"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 映射与函数 </tag>
            
            <tag> 高数课后练习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第二讲</title>
      <link href="/2023/01/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%8C%E8%AE%B2/"/>
      <url>/2023/01/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;数列极限&#x3D;&#x3D;</p><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%8C%E8%AE%B2/1.1.jpg" alt="1.1"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 数列极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第一讲</title>
      <link href="/2023/01/19/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/"/>
      <url>/2023/01/19/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-基础知识-x3D-x3D"><a href="#x3D-x3D-基础知识-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基础知识&#x3D;&#x3D;"></a>&#x3D;&#x3D;基础知识&#x3D;&#x3D;</h3><p>以下内容是对高数第一讲的总结，在这里参考讲义为张宇的基础30讲(高数部分)</p><span id="more"></span><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/../images/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/1.2.jpg"></p><p><img src="/../images/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/1.3-1674129185324.jpg" alt="1.3"></p><p><img src="/../images/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/1.4-1674129217571.jpg" alt="1.4"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4><p><img src="/2023/01/19/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/1.1.jpg" alt="1.1"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 高数基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/01/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/01/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="happy"><a href="#happy" class="headerlink" title="happy"></a>happy</h3><p>这是我的第一篇博客，搭建成功了很开心。主要目的就是为了记录一下自己的生活。今年打算考研了，因为本专业的原因，所以电子笔记更方便一点，也是为了将笔记上传到我的博客中方便以后查阅复习。当然最主要的目的就是为了记录一下自己的生活。相当于一个成长录吧。最重要的还是要坚持写下去，当然以后有更多好玩的事也会常常分享的。</p>]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
