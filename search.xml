<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高数第五讲</title>
      <link href="/2023/03/05/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%94%E8%AE%B2/"/>
      <url>/2023/03/05/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%94%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-基础知识-x3D-x3D"><a href="#x3D-x3D-基础知识-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基础知识&#x3D;&#x3D;"></a>&#x3D;&#x3D;基础知识&#x3D;&#x3D;</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/2023/03/05/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%94%E8%AE%B2/1.1.jpg" alt="1.1"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 一元函数微分学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第三章</title>
      <link href="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-第三章栈、队列和数组-x3D-x3D"><a href="#x3D-x3D-第三章栈、队列和数组-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第三章栈、队列和数组&#x3D;&#x3D;"></a>&#x3D;&#x3D;第三章栈、队列和数组&#x3D;&#x3D;</h2><h3 id="3-1栈"><a href="#3-1栈" class="headerlink" title="3.1栈"></a>3.1栈</h3><h4 id="3-1-1栈的基本概念"><a href="#3-1-1栈的基本概念" class="headerlink" title="3.1.1栈的基本概念"></a>3.1.1栈的基本概念</h4><p>栈的逻辑结构：与普通线性表相同</p><p>数据的运算：插入、删除操作有区别（栈只能在一端进行插入删除）</p><p><strong>栈的常考题型</strong></p><p>进栈顺序：a-&gt;b-&gt;c-&gt;d-&gt;e，有哪些出栈顺序？</p><p>可用公式代换</p><h4 id="3-1-2栈的顺序存储结构"><a href="#3-1-2栈的顺序存储结构" class="headerlink" title="3.1.2栈的顺序存储结构"></a>3.1.2栈的顺序存储结构</h4><p>GetTop:查：栈的使用场景中大多只访问栈顶元素</p><p>顺序栈缺点是：栈的大小不可变</p><p>我们可以给他分配一个大量的连续的存储空间，但是很可能会造成浪费，so，引入了共享栈的概念</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.1.png" alt="1.1"></p><h4 id="3-1-3栈的链式存储结构"><a href="#3-1-3栈的链式存储结构" class="headerlink" title="3.1.3栈的链式存储结构"></a>3.1.3栈的链式存储结构</h4><p>可以用链式存储方式进行存储</p><h3 id="3-2队列"><a href="#3-2队列" class="headerlink" title="3.2队列"></a>3.2队列</h3><h4 id="3-2-1队列的基本概念"><a href="#3-2-1队列的基本概念" class="headerlink" title="3.2.1队列的基本概念"></a>3.2.1队列的基本概念</h4><p>基本操作和列表相似，也是一种特殊的线性表，只不过是操作受限的。</p><h4 id="3-2-2队列的顺序存储结构"><a href="#3-2-2队列的顺序存储结构" class="headerlink" title="3.2.2队列的顺序存储结构"></a>3.2.2队列的顺序存储结构</h4><p><strong>初始化操作</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.2.png" alt="1.2"></p><p><strong>入队操作</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.3.png" alt="1.3"></p><p><strong>队列已满的条件：rear&#x3D;&#x3D;MaxSize?</strong></p><p>若是前面有元素出队了前面的位置会空出来，队列并没有存满。应该让rear指针重新指回下面的位置。变成<strong>循环队列</strong>。</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.4.png" alt="1.4"></p><p>可以取模运算，即得数会有{0,1,2,…,MaxSize-1}，将存储空间在逻辑上变成了<strong>环状</strong></p><p>队列已满的条件：队尾指针的下一个位置是队头，即(Q.rear+1)%MaxSize&#x3D;&#x3D;Q.front</p><p><strong>代价:牺牲一个存储单元</strong></p><p><strong>入队操作：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.5.png" alt="1.5"></p><p><strong>出队操作：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.6.png" alt="1.6"></p><p><strong>方案一：判断队列已满&#x2F;已空</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.7.png" alt="1.7"></p><p>比如说图中左边这个队列，里面元素个数计算方法可为：(2+10-3)%10&#x3D;9</p><p><strong>环形队列会浪费一个存储空间，有的出题老师要求不允许浪费，但是若是在左边存入一个的话，Q.rear&#x3D;Q.front，则队满队空就一样了，没有办法来判断了。</strong></p><p><strong>方案二：size值进行记录从而区分</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.8.png" alt="1.8"></p><p><strong>方案三：用tag值来进行区分</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.9.png" alt="1.9"></p><p><strong>其他出题方式：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.10.png" alt="1.10"></p><p><strong>初始化：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.11.png" alt="1.11"></p><p><strong>判断队列已满：</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.12.png" alt="1.12"></p><h4 id="3-2-3队列的链式存储结构"><a href="#3-2-3队列的链式存储结构" class="headerlink" title="3.2.3队列的链式存储结构"></a>3.2.3队列的链式存储结构</h4><p><strong>队列的链式实现</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.13.png" alt="1.13"></p><p><strong>初始化(带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.14.png" alt="1.14"></p><p><strong>初始化(不带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.15.png" alt="1.15"></p><p><strong>入队(带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.16.png" alt="1.16"></p><p><strong>入队(不带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.17.png" alt="1.17"></p><p><strong>出队(带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.18.png" alt="1.18"></p><p><strong>出队(不带头结点)</strong></p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.19.png" alt="1.19"></p><p><strong>队列满的条件</strong></p><p>顺序存储——预分配的空间耗尽时队满</p><p>链式存储——一般不会队满，除非内存不足</p><p>若是计算队列的长度，我们一般情况下是可以从front开始遍历，但是时间复杂度是O(n)，我们可以定义 int length;用来记录队列的长度</p><h4 id="3-2-4双端队列"><a href="#3-2-4双端队列" class="headerlink" title="3.2.4双端队列"></a>3.2.4双端队列</h4><p>栈：只允许从一端插入和删除的线性表</p><p>队列：只允许从一端插入、一段删除的线性表</p><p>双端队列：只允许从两端插入、两端删除的线性表</p><p><img src="/2023/03/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E7%AB%A0/1.20.png" alt="1.20"></p><p><strong>考点：判断输出序列合法性</strong></p><p>若数据元素输入序列为：1，2，3，4，则哪些输出序列是合法的，哪些是非法的？</p><p>栈中合法的序列，双端序列中也一定合法</p><p><strong>双端队列是队列的一个变种，共享栈也是栈的一个变种。</strong></p><h3 id="3-3栈和队列的应用"><a href="#3-3栈和队列的应用" class="headerlink" title="3.3栈和队列的应用"></a>3.3栈和队列的应用</h3><h3 id="3-4数组和特殊矩阵"><a href="#3-4数组和特殊矩阵" class="headerlink" title="3.4数组和特殊矩阵"></a>3.4数组和特殊矩阵</h3>]]></content>
      
      
      <categories>
          
          <category> 数据结构、 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈、队列和数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第四讲</title>
      <link href="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%9B%9B%E8%AE%B2/"/>
      <url>/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%9B%9B%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-基础知识-x3D-x3D"><a href="#x3D-x3D-基础知识-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基础知识&#x3D;&#x3D;"></a>&#x3D;&#x3D;基础知识&#x3D;&#x3D;</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%9B%9B%E8%AE%B2/1.1.jpg" alt="1.1"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E5%9B%9B%E8%AE%B2/1.2.jpg" alt="1.2"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 一元函数微分学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第三讲</title>
      <link href="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%89%E8%AE%B2/"/>
      <url>/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%89%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-基础知识-x3D-x3D"><a href="#x3D-x3D-基础知识-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基础知识&#x3D;&#x3D;"></a>&#x3D;&#x3D;基础知识&#x3D;&#x3D;</h3><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%89%E8%AE%B2/1.1.jpg" alt="1.1"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%89%E8%AE%B2/1.2.jpg" alt="1.2"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 函数极限与连续 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数重要公式</title>
      <link href="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="高数重要公式"><a href="#高数重要公式" class="headerlink" title="高数重要公式"></a>高数重要公式</h4><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/1.1.jpg" alt="1.1"></p><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/1.2.jpg" alt="1.2"></p><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/1.3.jpg" alt="1.3"></p><p><img src="/2023/02/28/%E9%AB%98%E6%95%B0%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F/1.4.jpg" alt="1.4"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 重要公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构算法</title>
      <link href="/2023/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="第二章线性表"><a href="#第二章线性表" class="headerlink" title="第二章线性表"></a>第二章线性表</h3><h4 id="2-2-3试题精选"><a href="#2-2-3试题精选" class="headerlink" title="2.2.3试题精选"></a>2.2.3试题精选</h4><h5 id="01"><a href="#01" class="headerlink" title="01"></a>01</h5><p>算法思想：搜索整个顺序表，找到最小值记住其位置，搜索结束后直接令最后第一元素填补该位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Del_Min</span><span class="params">(SqList &amp;L,ElemType &amp;value)</span>&#123;</span><br><span class="line">  <span class="comment">//删除顺序表L中最小值元素节点，并通过引用型参数value返回其值</span></span><br><span class="line">  <span class="comment">//若删除失败返回false</span></span><br><span class="line">  <span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  value=L.data[<span class="number">0</span>];<span class="comment">//value等于0号元素</span></span><br><span class="line">  <span class="type">int</span> pos=<span class="number">0</span>;<span class="comment">//假设0号元素最小</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;L.length;i++）</span><br><span class="line">      <span class="keyword">if</span>(L.data[i]&lt;value)&#123;</span><br><span class="line">        value=L.data[i];<span class="comment">//把最小值赋值给value</span></span><br><span class="line">        pos=i;<span class="comment">//记住最小值的位置</span></span><br><span class="line">      &#125;</span><br><span class="line">  L.data[pos]=L.data[L.length<span class="number">-1</span>];   <span class="comment">//把最后一个元素填补到最小值的位置</span></span><br><span class="line">  L.length--;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//此时，value的值为最小值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细解法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delMin</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!len) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组为空&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min = *arr, minPos = <span class="number">0</span>;<span class="comment">//min是第一个元素，minPos是第一个元素的位置</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; *(arr + i))&#123;</span><br><span class="line">min = *(arr + i);</span><br><span class="line">minPos = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到最小值之后，我们需要进行的操作是：将最后一个元素给他挪到之前最小值元素那里去</span></span><br><span class="line">*(arr + minPos) = *(arr + len - <span class="number">1</span>);  <span class="comment">//挪一下</span></span><br><span class="line">*(arr + len - <span class="number">1</span>) = <span class="literal">NULL</span>;<span class="comment">//挪完之后，要将这个位置上的元素设为NULL，因为现在数组的长度为length-1了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> n;<span class="comment">//手动输入数组的元素个数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数组长度：n=&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(n));<span class="comment">//动态分配数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数组的元素值：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr + i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">delMin(arr, n);<span class="comment">//调用delMin函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解：本题中主要是通过循环搜索整个顺序表，<strong>之后通过令最后一个元素填补，达到L.length–的目的</strong>。像这种类型算法，一般假设第一个元素是最小值，之后循环中比较即可。</p><h5 id="02"><a href="#02" class="headerlink" title="02"></a>02</h5><p>算法思想：逆置就是使元素按原顺序的相反顺序排序，我们可以将顺序表的前半部分与后半部分交换位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Recersr</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">ElemType temp;<span class="comment">//辅助变量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">temp=L.data[i];<span class="comment">//交换L.data[i]与L.data[L.legth-i-1]的位置</span></span><br><span class="line">L.data[i]=L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">L.data[L.length-i<span class="number">-1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细解法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法思想：逆置就是将前半部分与后半部分元素对换位置，根据数学关系联系起来即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseS</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;<span class="comment">//只需要i&lt;len/2就可以了</span></span><br><span class="line">tmp = arr[i];<span class="comment">//中间元素</span></span><br><span class="line">arr[i] = arr[len-i<span class="number">-1</span>];<span class="comment">//关于中间元素对称的元素交换位置，实现逆置</span></span><br><span class="line">arr[len-i<span class="number">-1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//手动输入数组的元素个数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数组长度：n=&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(n));<span class="comment">//动态分配数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入数组的元素值：&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">reverseS(arr, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理解：题目要求将顺序表中所有元素逆置，这种情况下我们可以前半部分和后半部分进行交换，达到逆置的效果。</p><h5 id="03"><a href="#03" class="headerlink" title="03"></a>03</h5><p>算法思想：k（k&#x3D;0）记录顺序表中不等于x的元素个数，在扫描过程中，将不等于x的元素移动到下标为k的位置，更新k的值，扫描结束后，修改L的长度。</p><p>解法一：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del_x_1</span><span class="params">(SqList &amp;L,ElemType x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>,i;<span class="comment">//记录不等于x的元素个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i]!=x)&#123;</span><br><span class="line">L.data[k]=L.data[i];<span class="comment">//将不等于x的元素移动到k的位置</span></span><br><span class="line">k++;<span class="comment">//更新k的值</span></span><br><span class="line">&#125;</span><br><span class="line">L.length=k;<span class="comment">//修改L的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于是扫描元素之后将不等于x的元素在L上覆盖了一遍，其中L中不等于x的数据元素的顺序没有改变。可以看做两个顺序表。</p><p>解法二：</p><p>算法思想：这种思想可以看做在本身表上直接移动，这个就是一个顺序表上进行操作。相当于遇到等于x的元素直接前移覆盖x，这样的话后面会空出来，直接L.length-k就可得到L的长度。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">del_x_2</span><span class="params">(SqList &amp;L,ElemType x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>;<span class="comment">//k值记录L中等于x的元素个数</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;L.length)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==x)</span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">L.data[i-k]=L.data[i];<span class="comment">//当前元素前移k个位置</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">L.length=L.length-k;<span class="comment">//顺序表的长度递减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="04"><a href="#04" class="headerlink" title="04"></a>04</h5><p>算法思想：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Del_s_t2</span><span class="params">(SqList &amp;L,ElemType s.ElemType t)</span>&#123;</span><br><span class="line"><span class="comment">//删除有序表L中值在给定值s与t之间的所有元素</span></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=t || L.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length &amp;&amp; L.data[i]&lt;s;i++)</span><br><span class="line"><span class="keyword">if</span>(i&gt;=L.length)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;L.length &amp;&amp; L.data[j]&lt;=t;j++)</span><br><span class="line"><span class="keyword">for</span>(;j&lt;L.length;i++;j++)</span><br><span class="line">L.data[i]=L.data[j];</span><br><span class="line">L.length=i;</span><br><span class="line"><span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数据结构算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第二章</title>
      <link href="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-第二章线性表-x3D-x3D"><a href="#x3D-x3D-第二章线性表-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;第二章线性表&#x3D;&#x3D;"></a>&#x3D;&#x3D;第二章线性表&#x3D;&#x3D;</h2><h3 id="2-1线性表的定义和基本操作"><a href="#2-1线性表的定义和基本操作" class="headerlink" title="2.1线性表的定义和基本操作"></a>2.1线性表的定义和基本操作</h3><h4 id="2-1-1线性表的定义"><a href="#2-1-1线性表的定义" class="headerlink" title="2.1.1线性表的定义"></a>2.1.1线性表的定义</h4><p><strong>相同</strong>(每个数据元素所占空间一样大)数据类型</p><p>有限序列(有次序)</p><p>第i个——位序</p><h4 id="2-1-2-线性表的基本操作"><a href="#2-1-2-线性表的基本操作" class="headerlink" title="2.1.2 线性表的基本操作"></a>2.1.2 线性表的基本操作</h4><p>Tips：</p><p>1.对数据的操作（记忆思路）——创销、增删改查</p><p>2.C语言函数的定义——&lt;返回值类型&gt;函数名(&lt;参数1类型&gt;参数1, &lt;参数2类型&gt;参数2…)</p><p>3.实际开发中，可根据实际需求定义其他的基本操作</p><p>4.函数名和参数的形式、命名都可以改变，but要有可读性</p><p><strong>5</strong>.什么时候要传入引用“&amp;”——对参数的修改结果需要“<strong>带回来</strong>”</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">x = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test函数内部 x=%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;调用test前 x=%d\n&quot;</span>, x);</span><br><span class="line">test(x);<span class="comment">//里面的x只是main的复制品</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;调用test后 x=%d\n&quot;</span>, x);<span class="comment">//对参数的修改没带回来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​结果：<img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.1.png" alt="1.1"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> &amp; x)</span> &#123;</span><br><span class="line">x = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;test函数内部 x=%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;调用test前 x=%d\n&quot;</span>, x);</span><br><span class="line">test(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;调用test后 x=%d\n&quot;</span>, x);<span class="comment">//对参数的修改带回来了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​结果：<img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.2.png" alt="1.2"></p><h3 id="2-2线性表的顺序表示"><a href="#2-2线性表的顺序表示" class="headerlink" title="2.2线性表的顺序表示"></a>2.2线性表的顺序表示</h3><h4 id="2-2-1顺序表的定义"><a href="#2-2-1顺序表的定义" class="headerlink" title="2.2.1顺序表的定义"></a>2.2.1顺序表的定义</h4><p>如何知道一个数据元素的大小？</p><p>C语言   sizeof(ElemType)，ElemType就是你的顺序表中存放的数据元素类型</p><p>顺序表所占的存储空间&#x3D;表长✖sizeof(元素的类型)</p><p><strong>静态分配：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> data[MaxSize];<span class="comment">// 用静态的“数组”存放数据元素</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">// 顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">// 顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作——初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;MaxSize; i++)</span><br><span class="line">    L.data[i] = <span class="number">0</span>;<span class="comment">// 将所有数据元素设置为默认初始值</span></span><br><span class="line">  L.length = <span class="number">0</span>;<span class="comment">// 顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">SqList L;<span class="comment">// 声明一个顺序表</span></span><br><span class="line">  InitList(L);<span class="comment">// 初始化顺序表</span></span><br><span class="line">  <span class="comment">//......未完待续，后续操作</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>静态数组的长度是不可变的，声明之后，数组的大小和空间事先已经固定，所以有一定的局限性</strong></p><p><strong>动态分配：</strong></p><p>Key：动态申请和释放内存空间</p><p>C —-     malloc、 free  函数</p><p>malloc：会申请一整片连续的内存空间</p><p>malloc 函数返回一个指针，需要强制转型为你定义的数据元素类型指针。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//malloc、free 函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10<span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="type">int</span> *data;<span class="comment">// 指示动态分配数组的指针</span></span><br><span class="line">  <span class="type">int</span> MaxSize;<span class="comment">// 顺序表的最大容量</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">// 顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">// 顺序表的类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本操作——初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">  <span class="comment">// 用 malloc 函数申请一片连续的存储空间</span></span><br><span class="line">  L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  L.length = <span class="number">0</span>;<span class="comment">// 顺序表初始长度为0</span></span><br><span class="line">  L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SeqList &amp;L, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">  <span class="type">int</span> *p = L.data;</span><br><span class="line">  L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize)+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;L.length; i++)&#123;</span><br><span class="line">    L.data[i]=p[i];     <span class="comment">// 将数据复制到新区域（but 时间开销大）</span></span><br><span class="line">  &#125;</span><br><span class="line">  L.MaxSize = L.MaxSize+len;<span class="comment">// 顺序表最大长度增加 len</span></span><br><span class="line">  <span class="built_in">free</span>(p);<span class="comment">// 释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">SqList L;<span class="comment">// 声明一个顺序表</span></span><br><span class="line">  InitList(L);<span class="comment">// 初始化顺序表</span></span><br><span class="line">  <span class="comment">//......往顺序表中随便插入几个元素</span></span><br><span class="line">  IncreaseSize(L,<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.3.png" alt="1.3"></p><p>绿色那块会被释放，因为 free 函数</p><p><strong>顺序表的特点：</strong></p><p>（1）随机访问：能在O(1)的时间内找到第i个元素</p><p>（2）存储密度高</p><p>（3）拓展容量不方便</p><p>（4）插入、删除操作不方便，需要移动大量元素</p><h4 id="2-2-2顺序表上基本操作的实现"><a href="#2-2-2顺序表上基本操作的实现" class="headerlink" title="2.2.2顺序表上基本操作的实现"></a>2.2.2顺序表上基本操作的实现</h4><p><strong>顺序表的基本操作——插入</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.4.png" alt="1.4"></p><p>其中i的合法值 [1,length+1]</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.5.png" alt="1.5"></p><p><strong>插入操作的时间复杂度</strong>——关注最深层循环语句的执行次数与问题规模n的关系</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.6.png" alt="1.6"></p><p>问题规模——   n&#x3D;L.length</p><p>最好情况——新元素插入表尾，不需要移动元素，i&#x3D;n+1,循环0次，                          最好时间复杂度 &#x3D; O(1)</p><p>最坏情况——新元素插入表头，需要将原有的n个元素全都向后移动，i&#x3D;1,循环n次，最好时间复杂度 &#x3D; O(1)</p><p>平均时间复杂度——p&#x3D;1&#x2F;(n+1)</p><p><strong>顺序表的基本操作——删除</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.7.png" alt="1.7"></p><p>e是引用变量，所以在bool和main中，都是同一个</p><p><strong>时间复杂度</strong>——见课本</p><p><strong>顺序表的按位查找</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 <span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> struce&#123;</span><br><span class="line">  <span class="type">int</span> *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">  <span class="type">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span>&#123;</span><br><span class="line">  <span class="comment">//用malloc 函数申请一片连续的存储空间</span></span><br><span class="line">  L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//注意是(int *)</span></span><br><span class="line">  L.length=<span class="number">0</span>;</span><br><span class="line">  L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​虽然指针指向的都是同一个地址，但是若是指针对应的数据类型对应错的话，访问数据元素的时候也会出现问题</p><p><strong>顺序表的按值查找</strong></p><p><strong>注意</strong>：基本数据类型：int、char、double、float 等可以直接用运算符“&#x3D;&#x3D;”比较，但是结构类型的数据元素不可比较</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.23.png" alt="1.23"></p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>(1)<strong>顺序存储结构和链式存储结构的区别：</strong></p><p>链表存储结构的内存地址不一定是连续的，但顺序存储结构的内存地址一定是连续的；</p><p>链式存储适用于在较频繁地插入、删除、更新元素时，而顺序存储结构适用于频繁查询时使用。</p><p>只有顺序表可以按序号随机存储，且在最后进行插入和删除操作时不需要移动任何元素</p><p>(2)<strong>顺序存储结构和链式存储结构的优缺点：</strong></p><p><strong>顺序存储：</strong>优点：可随机存取，存储密度高</p><p>​缺点：要求大片连续空间，改变容量不方便</p><p><strong>链式存储</strong>：优点：不要求大片连续空间，改变容量方便</p><p>​ 缺点：不可随机存储，要耗费一定空间存放指针</p><p>  空间上：</p><p>​顺序比链式节约空间。是因为链式结构每一个节点都有一个指针存储域。</p><p>存储操作上：</p><p>​顺序支持<strong>随机存取</strong>，方便操作</p><p>插入和删除上：</p><p>​链式的要比顺序的方便（因为插入的话顺序表也很方便，问题是顺序表的插入要执行更大的空间复杂度，包括一个从表头索引以及索引后的元素后移，而链表是索引后，插入就完成了）</p><p>​例如：当你在字典中查询一个字母j的时候，你可以选择两种方式，第一，顺序查询，从第一页依次查找直到查询到j。第二，索引查询，从字典的索引中，直接查出j的页数，直接找页数，或许是比顺序查询最快的。  </p><h3 id="2-3线性表的链式表示"><a href="#2-3线性表的链式表示" class="headerlink" title="2.3线性表的链式表示"></a>2.3线性表的链式表示</h3><h4 id="2-3-1单链表的定义"><a href="#2-3-1单链表的定义" class="headerlink" title="2.3.1单链表的定义"></a>2.3.1单链表的定义</h4><p>LNode:强调返回的是一个节点</p><p>LinkList:强调这是一个单链表</p><p>但是本质上两者表达的都是同一个意思</p><p><strong>不带头结点的单链表</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.8.png" alt="1.8"></p><p><strong>带头结点</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.9.png" alt="1.9"></p><p><strong>带头结点，写代码更方便一点</strong></p><h4 id="2-3-2单链表上的基本操作"><a href="#2-3-2单链表上的基本操作" class="headerlink" title="2.3.2单链表上的基本操作"></a>2.3.2单链表上的基本操作</h4><p><strong>按位序插入（带头结点）</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.10.png" alt="1.10"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.11.png" alt="1.11"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.12.png" alt="1.12"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.13.png" alt="1.13"></p><p><strong>按位序插入（不带头结点）</strong></p><p>这种情况除了i&#x3D;1位置的元素需要特殊处理之外，其余算法原理相同</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.14.png" alt="1.14"></p><p>推荐使用带头结点的方式</p><p><strong>指定节点的后插操作</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.15.png" alt="1.15"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.16.png" alt="1.16"></p><p><strong>指定节点的前插操作</strong></p><p>&#x2F;&#x2F;前插操作：在p节点之前插入元素e</p><p>第一种方法——传入头指针，循环查找p的前驱q，再对q后插，这种的时间复杂度是O(n)</p><p>第二种方法——可以直接在p节点后面插入一个新节点，之后通过赋值实现前插操作，这里时间复杂度是O(1)，此方法偷天换日，绝妙！</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.17.png" alt="1.17"></p><p><strong>按位序删除（带头结点）</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.18.png" alt="1.18"></p><p>最坏、平均时间复杂度：O(n)</p><p>最好时间复杂度：O(1)</p><p><strong>指定节点的删除</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.19.png" alt="1.19"></p><p>极限情况——若p节点正好是最后一个节点，p-&gt;next这行代码会报错</p><p><strong>由此可知，单链表的局限性：无法逆向检索，有时候太不方便了</strong></p><p><strong>按位查找</strong></p><p>极端情况：</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.20.png" alt="1.20"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.21.png" alt="1.21"></p><p>平均时间复杂度：O(n)</p><p><strong>按值查找</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.22.png" alt="1.22"></p><p>时间复杂度：O(n)</p><p>如果ElemType是更复杂的结构类型呢？</p><p>小节中有解决方法</p><p>求表的长度：</p><p>时间复杂度：O(n)</p><p><strong>尾插法建立单链表</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.24.png" alt="1.24"></p><p>but 每次都从头开始遍历，时间复杂度为O(n²) (0+1+2+…+(n-1)&#x3D;所以时间复杂度为O(n²))</p><p>&#x2F;&#x2F;后插操作</p><p>课本P29页有详细代码</p><p><strong>头插法建立单链表</strong></p><p>课本P28页见代码</p><p>养成好习惯，只要是初始化单链表，都先把头指针指向NULL</p><p>头插法：单链表的逆置</p><p><strong>知识回顾与重要知识点</strong></p><p>头插法、尾插法：核心就是初始化操作、指定节点的后插操作</p><p>(注意设置一个指向表尾节点的指针)</p><p><strong>头插法的重要应用：链表的逆置</strong></p><h4 id="2-3-3双链表"><a href="#2-3-3双链表" class="headerlink" title="2.3.3双链表"></a>2.3.3双链表</h4><p><strong>双链表的初始化</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.25.png" alt="1.25"></p><p><strong>双链表的插入</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.26.png" alt="1.26"></p><p><strong>双链表的删除</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.27.png" alt="1.27"></p><p><strong>双链表的遍历</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.28.png" alt="1.28"></p><h4 id="2-3-4循环链表"><a href="#2-3-4循环链表" class="headerlink" title="2.3.4循环链表"></a>2.3.4循环链表</h4><p><strong>循环单链表</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.29.png" alt="1.29"></p><p>单链表：从一个节点出发只能找到后续的各个节点</p><p>循环单链表：从一个节点出发可以找到其他任何一个节点</p><p><strong>循环双链表的初始化</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.30.png" alt="1.30"></p><p><strong>双链表的插入</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.31.png" alt="1.31"></p><p><strong>双链表的删除</strong></p><p>课本p33页见代码</p><h4 id="2-3-5静态链表"><a href="#2-3-5静态链表" class="headerlink" title="2.3.5静态链表"></a>2.3.5静态链表</h4><p><strong>用代码定义一个静态链表</strong></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.32.png" alt="1.32"></p><p>还有一种方法见课本</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.33.png" alt="1.33"></p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.34.png" alt="1.34"></p><p>SLinkList b —— 相当于定义了一个长度为MaxSize的Node型数组</p><p>静态链表：用数组的方式实现的链表</p><p>优点：增、删 操作不需要大量移动元素</p><p>缺点：不能随机存取，只能从头节点开始依次往后查找；<strong>容量固定不可变</strong>。</p><p>适用场景：不支持指针的低级语言；数据元素数量固定不变的场景(如操作系统的文件分配表FAT)</p><h4 id="2-3-6顺序表和链表的比较"><a href="#2-3-6顺序表和链表的比较" class="headerlink" title="2.3.6顺序表和链表的比较"></a>2.3.6顺序表和链表的比较</h4><p><strong>1.逻辑结构</strong></p><p>都属于线性表，都是线性结构</p><p><strong>2.物理结构&#x2F;存储结构</strong></p><p>顺序表：</p><p>优点：支持随机存储、存储密度高</p><p>缺点：大片连续空间分配不方便，改变容量不方便</p><p>链表：</p><p>优点：离散的小空间分配方便，改变容量方便</p><p>缺点：不可随机存取，存储密度低</p><p><strong>3.数据的运算&#x2F;基本操作</strong></p><p>创销、增删改查</p><p>顺序表（创）：</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.35.png" alt="1.35"></p><p>链表（创）：</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.36.png" alt="1.36"></p><p>顺序表（销）：</p><p>静态分配，系统会直接回收；若是动态分配，需要手动free(malloc和free必须成对出现)</p><p>链表（销）：</p><p>依次删除各个节点（free）</p><p>顺序表（增、删）：</p><p>插入&#x2F;删除元素都要将后续元素后移&#x2F;前移。时间复杂度：O(n)，时间开销主要来自移动元素。</p><p><strong>注意：</strong>若数据元素很大，则移动的时间代价很高</p><p>链表（增、删）：</p><p>插入&#x2F;删除元素只需修改指针即可。时间复杂度：O(n)，时间开销主要来自查找目标元素。</p><p><strong>注意：</strong>查找元素的时间代价更低</p><p>顺序表（查）：</p><p>按位查找：具体时间复杂度见课本P34</p><p>链表（查）：</p><p>见课表O(n)</p><p><img src="/2023/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0/1.37.png" alt="1.37"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数课后题1.2</title>
      <link href="/2023/02/03/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.2/"/>
      <url>/2023/02/03/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.2/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;高数课后题1.2&#x3D;&#x3D;</p><p><img src="/2023/02/03/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.2/1.1.jpg" alt="1.1"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 数列极限 </tag>
            
            <tag> 高数课后练习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构第一章</title>
      <link href="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-2-算法和算法评价"><a href="#1-2-算法和算法评价" class="headerlink" title="1.2 算法和算法评价"></a>1.2 算法和算法评价</h3><h5 id="1-2-1-算法的基本概念"><a href="#1-2-1-算法的基本概念" class="headerlink" title="1.2.1 算法的基本概念"></a>1.2.1 算法的基本概念</h5><p>注：算法必须是有穷的，而程序可以是无穷的</p><p><strong>高效率</strong>：花的时间少，时间复杂度低</p><p><strong>低存储量需求</strong>：不费内存，空间复杂度低</p><p><strong>评估算法时间开销</strong>：（可以用事后统计但是存在问题）：</p><p>（1）机器性能，如：超级计算机vs单片机</p><p>（2）编译语言：语言越高级，执行效率越低</p><p>（3）与编译程序产生的机器指令质量有关</p><p>（4）某些算法不可事后统计，如：导弹控制算法</p><h5 id="1-2-2-算法的时间复杂度"><a href="#1-2-2-算法的时间复杂度" class="headerlink" title="1.2.2 算法的时间复杂度"></a>1.2.2 算法的时间复杂度</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//算法一 —— 逐步递增型爱你</span></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">loveYou(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span> &#123;  <span class="comment">//n 为问题规模</span></span><br><span class="line">（<span class="number">1</span>）<span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//爱你的程度</span></span><br><span class="line">（<span class="number">2</span>） <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">（<span class="number">3</span>）i++;  <span class="comment">//每次+1</span></span><br><span class="line">（<span class="number">4</span>）  <span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">（<span class="number">5</span>）    <span class="built_in">printf</span>(<span class="string">&quot;I Love You More Than %d\n&quot;</span>,n);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句<strong>频度</strong>：</p><p>（1）——1次</p><p>（2）——3001次                                                                                                                                                                                                                                                                                         </p><p>（3）（4）——3000次</p><p>（5）——1次</p><p>T(3000)&#x3D;1+3001+2*3000+1</p><p>时间开销与问题规模n的关系:T(n)&#x3D;3n+3</p><p><strong>问题一：</strong>是否可以忽略表达式中的某些部分？</p><p><img src="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/1.1.png" alt="1.1"></p><p><strong>我们可以直接把低阶的部分去掉和系数变为1，保留阶数更高的部分就行</strong></p><p>T1(n)&#x3D;O(n)，其中O表示“同阶”，同等数量级。</p><p><strong>常见的渐进时间复杂：</strong>（常对幂指阶）</p><p><img src="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/1.2.png" alt="1.2"></p><p><strong>问题二：如果有好几千行代码，按这种方法需要一行一行数？</strong></p><p>​结论一：顺序执行的代码只会影响常数项，可以忽略</p><p>​结论二：只需挑循环中的<strong>一个基本操作</strong>分析它的执行次数与n的关系即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;<span class="comment">//外层循环执行n次</span></span><br><span class="line">i++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//嵌套两层循环</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am Iron Man\n&quot;</span>);<span class="comment">//内层循环共执行n²次</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You More Than %d\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​时间开销与问题规模的n的关系：</p><p>​T(n)&#x3D;O(n)+O(n²)&#x3D;O(n²)&#x2F;&#x2F;加法规则</p><p>​结论三：如果有多层嵌套循环，只需关注最深层循环循环了几次</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法3—— 指数递增型爱你</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//n 为问题规模</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;<span class="comment">//爱你的程度</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">i = i * <span class="number">2</span>;<span class="comment">//每次翻倍</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You More Than %d\n&quot;</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/1.3.png" alt="1.3"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法4—— 搜索数字型爱你</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> flag[], <span class="type">int</span> n)</span> &#123;<span class="comment">//n 为问题规模</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Am Iron Man\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//从第一个元素开始查找</span></span><br><span class="line"><span class="keyword">if</span> (flag[i] == n) &#123;<span class="comment">//找到元素n</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>, n);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//找到后跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//flag 数组中乱序存放了 1~n 这些数</span></span><br><span class="line"><span class="type">int</span> flag[n] = &#123; <span class="number">1.</span>...n &#125;;</span><br><span class="line">loveYou(flag, n);</span><br></pre></td></tr></table></figure><p>​计算上述算法的时间复杂度T(n):</p><p>​    最好情况：元素n在第一个位置–最好时间复杂度T(n)&#x3D;O(1)</p><p>​最坏情况：元素n在最后一个位置    –最坏时间复杂度T(n)&#x3D;O(n)</p><p>​平均情况：假设元素n在任意一个位置的概率相同为1&#x2F;n          –平均时间复杂度          T(n)&#x3D;O(n)</p><p><img src="/2023/02/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0/1.4.png" alt="1.4"></p><p><strong>很多算法执行时间与输入的数据有关</strong></p><h5 id="1-2-3-空间复杂度"><a href="#1-2-3-空间复杂度" class="headerlink" title="1.2.3 空间复杂度"></a>1.2.3 空间复杂度</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span> &#123;  <span class="comment">//n 为问题规模</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;  <span class="comment">//爱你的程度</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">i++;  <span class="comment">//每次+1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I Love You More Than %d\n&quot;</span>, n);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法中，不管n的值如何变化，它所需要的内存空间大小都是固定不变的一个常数值，算法<strong>空间复杂度</strong>为：    S(n) &#x3D; O(1)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  <span class="type">int</span> flagp[n];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">//......此处省略很多代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设一个int变量占 4B….. 则所需内存空间 &#x3D; 4+4n+4 &#x3D; 4n+8</p><p>则 S(n)&#x3D;O(n)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  <span class="type">int</span> flag[n][n];<span class="comment">//声明 n*n 维的二维数组</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">//......此处省略很多代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所需内存空间 &#x3D; 4n²+4          则 S(n)&#x3D;O(n²)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  <span class="type">int</span> flag[n][n];<span class="comment">//声明 n*n 维的二维数组</span></span><br><span class="line">  <span class="type">int</span> other[n];<span class="comment">//声明一个长度为n的数组</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">//......此处省略很多代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>S(n) &#x3D; O(n²)+O(n)+O(1)&#x3D;O(n²)       &#x2F;&#x2F;加法规则</p><p><strong>函数递归调用带来的内存开销</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法5—— 递归型爱你</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="comment">//n 为局部变量</span></span><br><span class="line">  <span class="type">int</span> a, b, c;<span class="comment">//声明一系列局部变量</span></span><br><span class="line">  <span class="comment">//...... 省略代码</span></span><br><span class="line">  <span class="keyword">if</span> (n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    loveYou(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  loveYou(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设每层调用k个字节，则n层就是kn个字节</p><p>S(n)&#x3D;O(n)<strong>空间复杂度&#x3D;递归调用的深度</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//算法5—— 递归型爱你</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loveYou</span><span class="params">(<span class="type">int</span> n)</span>&#123;<span class="comment">//n 为局部变量</span></span><br><span class="line">  <span class="type">int</span> flag[n];<span class="comment">//声明一个数组</span></span><br><span class="line">  <span class="type">int</span> a, b, c;<span class="comment">//声明一系列局部变量</span></span><br><span class="line">  <span class="comment">//...... 省略代码</span></span><br><span class="line">  <span class="keyword">if</span> (n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">    loveYou(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;I Love You %d\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  loveYou(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各级递归调用所需要的存储flag数组的空间为：1+2+3+….+n&#x3D;[n(1+n)&#x2F;2]&#x3D;(1&#x2F;2)n²+(1&#x2F;2)n</p><p>S(n)&#x3D;O(n²)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数据结构第一章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数课后题1.1</title>
      <link href="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/"/>
      <url>/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;高数课后题1.1&#x3D;&#x3D;</p><p>课本是同济大学数学系编，只做了一些重点题。</p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.1.jpg" alt="1.1"></p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.2.jpg" alt="1.2"></p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.3.jpg" alt="1.3"></p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.4.jpg" alt="1.4"></p><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E8%AF%BE%E5%90%8E%E9%A2%981.1/1.5.jpg" alt="1.5"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 映射与函数 </tag>
            
            <tag> 高数课后练习题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第二讲</title>
      <link href="/2023/01/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%8C%E8%AE%B2/"/>
      <url>/2023/01/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%8C%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<p>&#x3D;&#x3D;数列极限&#x3D;&#x3D;</p><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/2023/01/28/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%BA%8C%E8%AE%B2/1.1.jpg" alt="1.1"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 数列极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数第一讲</title>
      <link href="/2023/01/19/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/"/>
      <url>/2023/01/19/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="x3D-x3D-基础知识-x3D-x3D"><a href="#x3D-x3D-基础知识-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;基础知识&#x3D;&#x3D;"></a>&#x3D;&#x3D;基础知识&#x3D;&#x3D;</h3><p>以下内容是对高数第一讲的总结，在这里参考讲义为张宇的基础30讲(高数部分)</p><span id="more"></span><h4 id="1-总结"><a href="#1-总结" class="headerlink" title="1.总结"></a>1.总结</h4><p><img src="/../images/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/1.2.jpg"></p><p><img src="/../images/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/1.3-1674129185324.jpg" alt="1.3"></p><p><img src="/../images/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/1.4-1674129217571.jpg" alt="1.4"></p><h4 id="2-思维导图"><a href="#2-思维导图" class="headerlink" title="2.思维导图"></a>2.思维导图</h4><p><img src="/2023/01/19/%E9%AB%98%E6%95%B0%E7%AC%AC%E4%B8%80%E8%AE%B2/1.1.jpg" alt="1.1"></p>]]></content>
      
      
      <categories>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
            <tag> 高数基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/01/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/01/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="happy"><a href="#happy" class="headerlink" title="happy"></a>happy</h3><p>这是我的第一篇博客，搭建成功了很开心。主要目的就是为了记录一下自己的生活。今年打算考研了，因为本专业的原因，所以电子笔记更方便一点，也是为了将笔记上传到我的博客中方便以后查阅复习。当然最主要的目的就是为了记录一下自己的生活。相当于一个成长录吧。最重要的还是要坚持写下去，当然以后有更多好玩的事也会常常分享的。</p>]]></content>
      
      
      <categories>
          
          <category> 日常记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
